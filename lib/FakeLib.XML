<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FakeLib</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.AdditionalSyntax.op_EqualsQmarkGreater(System.String,System.String,System.Boolean)">
<summary>
 Defines a conditional dependency - y is dependent on x if the condition is true
</summary>
</member>
<member name="M:Fake.AdditionalSyntax.op_LessEqualsGreater(System.String,System.String)">
<summary>
 Defines that x and y are not dependent on each other but y is dependent on all dependencies of x.
</summary>
</member>
<member name="M:Fake.AdditionalSyntax.op_EqualsEqualsGreater(System.String,System.String)">
<summary>
 Defines a dependency - y is dependent on x
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fake.AdditionalSyntax.sameLevels">
<summary>
 Stores which targets are on the same level
</summary>
</member>
<member name="M:Fake.AdditionalSyntax.RunParameterTargetOrDefault(System.String,System.String)">
<summary>
 Runs the target given by the build script parameter or the given default target
</summary>
</member>
<member name="P:Fake.AdditionalSyntax.Run">
<summary>
 Runs a Target and its dependencies
</summary>
</member>
<member name="M:Fake.AdditionalSyntax.And``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Appends the dependency to the list of dependencies
</summary>
</member>
<member name="M:Fake.AdditionalSyntax.Dependency``1(``0)">
<summary>
 Converts a dependency into a list
</summary>
</member>
<member name="M:Fake.AdditionalSyntax.For(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Allows to use For? syntax for Dependencies
</summary>
</member>
<member name="M:Fake.AdditionalSyntax.op_DynamicAssignment``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},``0,``1)">
<summary>
 Allows to use Tokens instead of strings for TargetNames
</summary>
</member>
<member name="M:Fake.AdditionalSyntax.op_Dynamic``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0)">
<summary>
 Allows to use Tokens instead of strings
</summary>
</member>
<member name="T:Fake.AdditionalSyntax">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fake.AssemblyInfoHelper.AssemblyInfoReplacementDefaults">
<summary>
 AssemblyInfoReplacement default params
</summary>
</member>
<member name="M:Fake.AssemblyInfoHelper.AssemblyInfo(Microsoft.FSharp.Core.FSharpFunc`2{Fake.AssemblyInfoHelper.AssemblyInfoParams,Fake.AssemblyInfoHelper.AssemblyInfoParams})">
<summary>
 Generates an AssemblyInfo file for projects
</summary>
</member>
<member name="M:Fake.AssemblyInfoHelper.generateFile(Fake.AssemblyInfoHelper.AssemblyInfoParams,System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.IEnumerable{System.String},System.IO.TextWriter)">
<summary>
 generates the assembly info file
</summary>
</member>
<member name="P:Fake.AssemblyInfoHelper.AssemblyInfoDefaults">
<summary>
 AssemblyInfo default params
</summary>
</member>
<member name="T:Fake.AssemblyInfoHelper">

</member>
<member name="M:Fake.AsyncHelper.doParallel``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Runs the given function on all items in parallel
</summary>
</member>
<member name="T:Fake.AsyncHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.BuildServerHelper.TraceMode">
<summary>
 The trace Mode type.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.BuildServerHelper.BuildServer">
<summary>
 The BuildServer type.
</summary>
</member>
<member name="P:Fake.BuildServerHelper.isLocalBuild">
<summary>
 Determines if the current build is a local build.
</summary>
</member>
<member name="P:Fake.BuildServerHelper.buildServer">
<summary>
 Determines the current BuildVersion and if it is a local build
</summary>
</member>
<member name="P:Fake.BuildServerHelper.buildVersion">
<summary>
 Determines the current BuildVersion and if it is a local build
</summary>
</member>
<member name="P:Fake.BuildServerHelper.ccBuildLabel">
<summary>
 CruiseControl.NET Build label
</summary>
</member>
<member name="P:Fake.BuildServerHelper.jenkinsBuildNumber">
<summary>
 Build number retrieved from Jenkins
</summary>
</member>
<member name="P:Fake.BuildServerHelper.tcBuildNumber">
<summary>
 Build number retrieved from TeamCity
</summary>
</member>
<member name="P:Fake.BuildServerHelper.xmlOutputFile">
<summary>
 Definces the XML output file
 Used for BuildServers like CruiseControl.NET
</summary>
</member>
<member name="P:Fake.BuildServerHelper.localBuildLabel">
<summary>
 A constant for local builds            
</summary>
</member>
<member name="P:Fake.BuildServerHelper.verbose">
<summary>
 Trace verbose output
</summary>
</member>
<member name="T:Fake.BuildServerHelper">

</member>
<member name="M:Fake.CacheHelper.lookup``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``1},System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Looks for a key in the cache.
 If it is not found the newValue functions is executed and the result is stored in the cache.
</summary>
</member>
<member name="T:Fake.CacheHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.DeploymentAgent">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.DeploymentHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fake.DocuHelper.DocuDefaults">
<summary>
 Docu default params  
</summary>
</member>
<member name="T:Fake.DocuHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fake.EnvironmentHelper.documentsFolder">
<summary>
 The path to the personal documents
</summary>
</member>
<member name="M:Fake.EnvironmentHelper.getTargetPlatformDir(System.String)">
<summary>
 Gets the local directory for the given target platform
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fake.EnvironmentHelper.ProgramFilesX86">
<summary>
 The path of Program Files (x86)
</summary>
</member>
<member name="P:Fake.EnvironmentHelper.ProgramFiles">
<summary>
 The path of Program Files - might be x64 on x64 machine
</summary>
</member>
<member name="M:Fake.EnvironmentHelper.getBuildParamOrDefault(System.String,System.String)">
<summary>
 Returns the value of the buildParam if it is set and otherwise the default
</summary>
</member>
<member name="M:Fake.EnvironmentHelper.getBuildParam(System.String)">
<summary>
 Returns the value of the buildParam if it is set and otherwise &quot;&quot; 
</summary>
</member>
<member name="M:Fake.EnvironmentHelper.hasBuildParam(System.String)">
<summary>
 Returns true if the buildParam is set and otherwise false
</summary>
</member>
<member name="M:Fake.EnvironmentHelper.appSetting(System.String)">
<summary>
 Retrieves a ApplicationSettings variable
</summary>
</member>
<member name="">

</member>
<member name="M:Fake.EnvironmentHelper.environVarOrDefault(System.String,System.String)">
<summary>
 Retrieves the EnvironmentVariable or a default
</summary>
</member>
<member name="M:Fake.EnvironmentHelper.setEnvironVar(System.String,System.String)">
<summary>
 Sets the Environment variable
</summary>
</member>
<member name="M:Fake.EnvironmentHelper.environVars(System.EnvironmentVariableTarget)">
<summary>
 Retrieves the EnvironmentVariable
</summary>
</member>
<member name="M:Fake.EnvironmentHelper.op_AtAt(System.String,System.String)">
<summary>
 Combines two path strings
</summary>
</member>
<member name="M:Fake.EnvironmentHelper.combinePaths(System.String,System.String)">
<summary>
 Combines two path strings
</summary>
</member>
<member name="M:Fake.EnvironmentHelper.environVar(System.String)">
<summary>
 Retrieves the EnvironmentVariable
</summary>
</member>
<member name="T:Fake.EnvironmentHelper">

</member>
<member name="">

</member>
<member name="M:Fake.FSIHelper.runBuildScriptAt(System.String,System.Boolean,System.String,System.Collections.Generic.IEnumerable{System.Tuple`2{System.String,System.String}})">
<summary>
 Run the given buildscript with fsi.exe
</summary>
</member>
<member name="P:Fake.FSIHelper.fsiPath">
<summary>
 The Path to the F# interactive tool
</summary>
</member>
<member name="T:Fake.FSIHelper">

</member>
<member name="M:Fake.FileHelper.MoveFile(System.String,System.String)">
 <summary>Moves a single file to the target and overwrites the existing file.</summary>
 <param name="target">The target directory.</param>
 <param name="fileName">The FileName.</param>
</member>
<member name="M:Fake.FileHelper.CopyRecursive(System.String,System.String)">
<summary>
 Copies the file structure recursive
</summary>
</member>
<member name="M:Fake.FileHelper.copyRecursive(System.IO.DirectoryInfo,System.IO.DirectoryInfo,System.Boolean)">
<summary>
 Copies the file structure recursive
</summary>
</member>
<member name="M:Fake.FileHelper.GeneratePatch(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
 <summary>Checks the srcFiles for changes to the last release.</summary>
 <param name="lastReleaseDir">The directory of the last release.</param>
 <param name="patchDir">The target directory.</param>
 <param name="srcFiles">The source files.</param>
</member>
<member name="M:Fake.FileHelper.GeneratePatchWithFindOldFileFunction(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.FSharpFunc`2{System.String,System.String}})">
 <summary>Checks the srcFiles for changes to the last release.</summary>
 <param name="lastReleaseDir">The directory of the last release</param>
 <param name="patchDir">The target directory</param>
 <param name="srcFiles">The source files</param>
 <param name="findOldFileF">A function which finds the old file</param>
</member>
<member name="M:Fake.FileHelper.TestDir(System.String)">
<summary>
 Checks if the directory exists
</summary>
</member>
<member name="M:Fake.FileHelper.CompareFiles(System.Boolean,System.String,System.String)">
<summary>
 Compares the given files for changes
 If delete = true then equal files will be removed  
</summary>
</member>
<member name="M:Fake.FileHelper.FilesAreEqual(System.IO.FileInfo,System.IO.FileInfo)">
<summary>
 Checks if the two files are byte-to-byte equal.
</summary>
</member>
<member name="M:Fake.FileHelper.AppendTextFiles(System.String,System.Collections.Generic.IEnumerable{System.String})">
 <summary>Appends all given files to one file.</summary>
 <param name="newFileName">The target FileName.</param>
 <param name="files">The original FileNames as a sequence.</param>
</member>
<member name="M:Fake.FileHelper.ReadCSVFile(System.String)">
<summary>
 Reads a csv file line by line
 delimiter is a ,
</summary>
</member>
<member name="M:Fake.FileHelper.DeleteDirs(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Delete multiple directories
</summary>
</member>
<member name="M:Fake.FileHelper.CleanDirs(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Clean multiple directories
</summary>
</member>
<member name="M:Fake.FileHelper.CleanDir(System.String)">
<summary>
 Cleans a directory
</summary>
</member>
<member name="M:Fake.FileHelper.CopyDir(System.String,System.String,Microsoft.FSharp.Core.FSharpFunc`2{System.String,System.Boolean})">
 <summary>Copies a directory recursivly.
 If the target directory does not exist, it will be created.</summary>
 <param name="target">The target directory.</param>
 <param name="files">The source directory.</param>
 <param name="filterFile">A file filter function.</param>
</member>
<member name="M:Fake.FileHelper.allFiles(System.String)">
<summary>
 Includes all files
</summary>
</member>
<member name="M:Fake.FileHelper.excludeSVNFiles(System.String)">
<summary>
 Exclude SVN files (path with .svn)
</summary>
</member>
<member name="M:Fake.FileHelper.CopyFiles(System.String,System.Collections.Generic.IEnumerable{System.String})">
 <summary>Copies the files to the target - Alias for Copy</summary>
 <param name="target">The target FileName.</param>
 <param name="file">The orginal FileName.</param>
</member>
<member name="">

</member>
<member name="M:Fake.FileHelper.Rename(System.String,System.String)">
 <summary>Renames the files to the target fileName.</summary>
 <param name="target">The target FileName.</param>
 <param name="file">The orginal FileName.</param>
</member>
<member name="M:Fake.FileHelper.CopyCached(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Copies the files from a cache folder.
 If the files are not cached or the original files have a different write time the cache will be refreshed.
 &lt;param name=&quot;target&quot;&gt;The target FileName.&lt;/param&gt;
 &lt;param name=&quot;cacheDir&quot;&gt;The cache directory.&lt;/param&gt;
 &lt;param name=&quot;files&quot;&gt;The orginal files.&lt;/param&gt;
</summary>
</member>
<member name="M:Fake.FileHelper.CopyTo(System.String)">
 <summary>Copies the given files to the target.</summary>
 <param name="target">The target directory.</param>
</member>
<member name="M:Fake.FileHelper.Copy(System.String,System.Collections.Generic.IEnumerable{System.String})">
 <summary>Copies the files to the target.</summary>
 <param name="target">The target directory.</param>
 <param name="files">The original FileNames as a sequence.</param>
</member>
<member name="M:Fake.FileHelper.CopyFile(System.String,System.String)">
 <summary>Copies a single file to the target and overwrites the existing file.</summary>
 <param name="target">The target directory.</param>
 <param name="fileName">The FileName.</param>
</member>
<member name="M:Fake.FileHelper.CopyFileIntoSubFolder(System.String,System.String)">
 <summary>Copies a single file to a relative subfolder of the target.</summary>
 <param name="target">The target directory</param>
 <param name="fileName">The fileName</param>
</member>
<member name="M:Fake.FileHelper.|FileInfoNameSections|(System.IO.FileInfo)">
<summary>
 Active Pattern for determining FileInfoNameSections
</summary>
</member>
<member name="M:Fake.FileHelper.|FileInfoFullName|(System.IO.FileInfo)">
<summary>
 Active Pattern for determining file name   
</summary>
</member>
<member name="M:Fake.FileHelper.|EndsWith|_|(System.String,System.String)">
<summary>
 Active Pattern for determining file extension
</summary>
</member>
<member name="">

</member>
<member name="M:Fake.FileHelper.DeleteFiles(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Deletes files
</summary>
</member>
<member name="M:Fake.FileHelper.DeleteFile(System.String)">
<summary>
 Deletes a file if it exist
</summary>
</member>
<member name="M:Fake.FileHelper.CreateFile(System.String)">
<summary>
 Creates a file if it does not exist
</summary>
</member>
<member name="M:Fake.FileHelper.CreateDir(System.String)">
<summary>
 Creates a directory if it does not exist
</summary>
</member>
<member name="M:Fake.FileHelper.DeleteDir(System.String)">
<summary>
 Deletes a directory if it exists
</summary>
</member>
<member name="M:Fake.FileHelper.SetReadOnly(System.Boolean,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Sets all files in the directory readonly 
</summary>
</member>
<member name="M:Fake.FileHelper.SetDirReadOnly(System.Boolean,System.IO.DirectoryInfo)">
<summary>
 Sets all files in the directory readonly 
</summary>
</member>
<member name="M:Fake.FileHelper.setDirectoryReadOnly(System.Boolean,System.IO.DirectoryInfo)">
<summary>
 Sets the directory readonly 
</summary>
</member>
<member name="M:Fake.FileHelper.recursively(Microsoft.FSharp.Core.FSharpFunc`2{System.IO.DirectoryInfo,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.IO.FileInfo,Microsoft.FSharp.Core.Unit},System.IO.DirectoryInfo)">
<summary>
 Performs the given actions on all files and subdirectories
</summary>
</member>
<member name="T:Fake.FileHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.FileSetHelper.LazyFileSet">
<summary>
 The FileSet is lazy loaded into a sequence of strings.
 Every time the FileSet is used it scans again.
</summary>
</member>
<member name="T:Fake.FileSetHelper.EagerFileSet">
<summary>
 The FileSet is eagerly loaded into a list of strings.
 The scan is only done once.
</summary>
</member>
<member name="M:Fake.FileSetHelper.AllFilesMatching(System.String)">
<summary>
 Includes a single pattern and scans the files - !! x = AllFilesMatching x
</summary>
</member>
<member name="M:Fake.FileSetHelper.op_BangBang(System.String)">
<summary>
 Includes a single pattern and scans the files - !! x = AllFilesMatching x
</summary>
</member>
<member name="M:Fake.FileSetHelper.op_MinusMinus(Fake.FileSetHelper.FileIncludes,System.String)">
<summary>
 Exclude operator
</summary>
</member>
<member name="M:Fake.FileSetHelper.op_PlusPlus(Fake.FileSetHelper.FileIncludes,System.String)">
<summary>
 Add Include operator
</summary>
</member>
<member name="M:Fake.FileSetHelper.op_BangPlus(System.String)">
<summary>
 Include prefix operator
</summary>
</member>
<member name="M:Fake.FileSetHelper.ScanImmediately(Fake.FileSetHelper.FileIncludes)">
<summary>
 Scans immediately for include files
 Files will be memoized
</summary>
</member>
<member name="M:Fake.FileSetHelper.SetBaseDir(System.String,Fake.FileSetHelper.FileIncludes)">
<summary>
 Sets a directory as baseDirectory for fileIncludes  
</summary>
</member>
<member name="M:Fake.FileSetHelper.AddBaseDir(System.String,Fake.FileSetHelper.FileIncludes)">
<summary>
 Adds a directory as baseDirectory for fileIncludes  
</summary>
</member>
<member name="M:Fake.FileSetHelper.Scan(Fake.FileSetHelper.FileIncludes)">
<summary>
 Lazy scan for include files
 Will be processed at the time when needed
</summary>
</member>
<member name="M:Fake.FileSetHelper.Include(System.String)">
<summary>
 Include files  
</summary>
</member>
<member name="P:Fake.FileSetHelper.DefaultBaseDir">
<summary>
 The default base directory 
</summary>
</member>
<member name="M:Fake.FileSetHelper.Log(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Logs the given files with the message  
</summary>
</member>
<member name="M:Fake.FileSetHelper.Files(System.Collections.Generic.IEnumerable{System.String},Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Searches the directories recursively for files and directories matching 
 the search criteria.    
</summary>
</member>
<member name="M:Fake.FileSetHelper.scanDirectory(System.Boolean,Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{Fake.FileSetHelper.RegexEntry},Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{Fake.FileSetHelper.RegexEntry},System.String,System.Boolean)">
<summary>
 Searches a directory recursively for files and directories matching 
 the search criteria.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.FileSetHelper.convertPatterns(System.IO.DirectoryInfo,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Parses specified search patterns for search directories and 
 corresponding regex patterns.
</summary>
</member>
<member name="M:Fake.FileSetHelper.parseSearchDirectoryAndPattern(System.IO.DirectoryInfo,System.String)">
<summary>
 Given a search pattern returns a search directory and an regex search pattern.
</summary>
</member>
<member name="M:Fake.FileSetHelper.regexPattern(System.String)">
<summary>
 Converts search pattern to a regular expression pattern.
</summary>
</member>
<member name="M:Fake.FileSetHelper.ensureEndsWithSlash(System.String)">
<summary>
 Ensures that the last character of the given &lt;see cref=&quot;string&quot; /&gt;
 matches Path.DirectorySeparatorChar.          
</summary>
</member>
<member name="M:Fake.FileSetHelper.baseDirectory(System.String)">
<summary>
 The base directory to scan. The default is the 
 &lt;see cref=&quot;Environment.CurrentDirectory&quot;&gt;current directory&lt;/see&gt;.
</summary>
</member>
<member name="">

</member>
<member name="M:Fake.FileSetHelper.cleanPath(System.String)">
<summary>
 Patterns can use either / \ as a directory separator.
 cleanPath replaces both of these characters with Path.DirectorySeparatorChar
</summary>
</member>
<member name="M:Fake.FileSetHelper.cleanPathBuilder(System.String)">
<summary>
 Patterns can use either / \ as a directory separator.
 cleanPath replaces both of these characters with Path.DirectorySeparatorChar
</summary>
</member>
<member name="T:Fake.FileSetHelper">

</member>
<member name="M:Fake.FileSystemHelper.ensureDirectory(System.String)">
<summary>
 Checks if all given directory exists. If not then this functions creates the directory
</summary>
</member>
<member name="M:Fake.FileSystemHelper.allFilesExist(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Checks if all given files exists
</summary>
</member>
<member name="M:Fake.FileSystemHelper.checkFileExists(System.String)">
<summary>
 Checks if the file exists on disk.
</summary>
</member>
<member name="P:Fake.FileSystemHelper.currentDirectory">
<summary>
 Gets the current directory
</summary>
</member>
<member name="M:Fake.FileSystemHelper.FindFirstMatchingFile(System.String,System.String)">
<summary>
 Gets the first file in the directory matching the search pattern or throws if nothing was found
</summary>
</member>
<member name="M:Fake.FileSystemHelper.TryFindFirstMatchingFile(System.String,System.String)">
<summary>
 Gets the first file in the directory matching the search pattern or None
</summary>
</member>
<member name="M:Fake.FileSystemHelper.filesInDirMatching(System.String,System.IO.DirectoryInfo)">
<summary>
 Finds all the files in the directory matching the search pattern 
</summary>
</member>
<member name="M:Fake.FileSystemHelper.filesInDir(System.IO.DirectoryInfo)">
<summary>
 Gets all files in the directory
</summary>
</member>
<member name="M:Fake.FileSystemHelper.subDirectories(System.IO.DirectoryInfo)">
<summary>
 Gets all subdirectories
</summary>
</member>
<member name="M:Fake.FileSystemHelper.DirectoryName(System.String)">
<summary>
 Gets the directory part of a filename
</summary>
</member>
<member name="M:Fake.FileSystemHelper.FullName(System.String)">
<summary>
 Converts a file to it&apos;s full file system name
</summary>
</member>
<member name="M:Fake.FileSystemHelper.fileSystemInfo(System.String)">
<summary>
 Creates a FileInfo or a DirectoryInfo for the given path
</summary>
</member>
<member name="M:Fake.FileSystemHelper.fileInfo(System.String)">
<summary>
 Creates a FileInfo for the given path
</summary>
</member>
<member name="M:Fake.FileSystemHelper.directoryInfo(System.String)">
<summary>
 Creates a DirectoryInfo for the given path
</summary>
</member>
<member name="T:Fake.FileSystemHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.FileUtils">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.FxCopHelper.FxCop(Microsoft.FSharp.Core.FSharpFunc`2{Fake.FxCopHelper.FxCopParams,Fake.FxCopHelper.FxCopParams},System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Run FxCop on a group of assemblies.
</summary>
</member>
<member name="P:Fake.FxCopHelper.FxCopDefaults">
<summary>
 FxCop Default params  
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.FxCopHelper">

</member>
<member name="M:Fake.Git.Branches.pull(System.String,System.String,System.String)">
<summary>
 Pull
</summary>
</member>
<member name="M:Fake.Git.Branches.push(System.String)">
<summary>
 Push all
</summary>
</member>
<member name="M:Fake.Git.Branches.checkout(System.String,System.Boolean,System.String)">
<summary>
 Checks a branch out
</summary>
</member>
<member name="M:Fake.Git.Branches.checkoutTracked(System.String,System.String,System.String)">
<summary>
 Checks a branch out
</summary>
</member>
<member name="M:Fake.Git.Branches.deleteTag(System.String,System.String)">
<summary>
 Deletes the given tag
</summary>
</member>
<member name="M:Fake.Git.Branches.tag(System.String,System.String)">
<summary>
 Tags the current branch
</summary>
</member>
<member name="M:Fake.Git.Branches.deleteBranch(System.String,System.Boolean,System.String)">
<summary>
 Deletes the given branch
</summary>
</member>
<member name="M:Fake.Git.Branches.createBranch(System.String,System.String,System.String)">
<summary>
 Creates a new branch from the given commit
</summary>
</member>
<member name="M:Fake.Git.Branches.checkoutBranch(System.String,System.String)">
<summary>
 Performs a checkout of the given branch to the working copy
</summary>
</member>
<member name="M:Fake.Git.Branches.checkoutNewBranch(System.String,System.String,System.String)">
 <summary>Creates a new branch based on the given baseBranch and checks it out to the working copy</summary>
 <param name="repositoryDir">The repository directory.</param>
 <param name="baseBranch">The base branch.</param>
 <param name="branch">The new branch.</param>
</member>
<member name="M:Fake.Git.Branches.revisionsBetween(System.String,System.String,System.String)">
<summary>
 Returns the number of revisions between the two given commits
</summary>
</member>
<member name="M:Fake.Git.Branches.findMergeBase(System.String,System.String,System.String)">
<summary>
 Returns the SHA1 of the merge base of the two given commits
</summary>
</member>
<member name="M:Fake.Git.Branches.getSHA1(System.String,System.String)">
<summary>
 Returns the SHA1 of the given head
</summary>
</member>
<member name="M:Fake.Git.Branches.getAllBranches(System.String)">
<summary>
 Gets all local and remote branches
</summary>
</member>
<member name="M:Fake.Git.Branches.getRemoteBranches(System.String)">
<summary>
 Gets all remote branches
</summary>
</member>
<member name="M:Fake.Git.Branches.getLocalBranches(System.String)">
<summary>
 Gets all local branches
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.Git.Branches">

</member>
<member name="M:Fake.Git.CommandHelper.findGitDir(System.String)">
<summary>
 Searches the git dir recursivly up to the root
</summary>
</member>
<member name="">

</member>
<member name="M:Fake.Git.CommandHelper.runSimpleGitCommand(System.String,System.String)">
<summary>
 Runs the git command and returns the first line of the result
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Git.CommandHelper.directExec(Microsoft.FSharp.Core.FSharpFunc`2{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit})">
<summary>
 Runs the given process and returns the exit code
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.Git.CommandHelper">

</member>
<member name="M:Fake.Git.CommitMessage.setMessage(System.String,System.String)">
<summary>
 Sets the commit message
</summary>
</member>
<member name="M:Fake.Git.CommitMessage.getCommitMessage(System.String)">
<summary>
 Gets the commit message
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.Git.CommitMessage">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Git.FileStatus.cleanWorkingCopy(System.String)">
<summary>
 Cleans the working copy by doing a git reset --hard and a clean -f
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Git.FileStatus.isInTheMiddleOfConflictedMerge(System.String)">
<summary>
 Returns true if the working copy is in a conflicted merge otherwise false
</summary>
</member>
<member name="M:Fake.Git.FileStatus.getConflictedFiles(System.String)">
<summary>
 Gets all conflicted files
</summary>
</member>
<member name="M:Fake.Git.FileStatus.getChangedFilesInWorkingCopy(System.String,System.String)">
<summary>
 Gets the changed files since the given revision incl. changes in the working copy
</summary>
</member>
<member name="M:Fake.Git.FileStatus.getAllFiles(System.String)">
<summary>
 Gets all changed files in the current revision
</summary>
</member>
<member name="M:Fake.Git.FileStatus.getChangedFiles(System.String,System.String,System.String)">
<summary>
 Gets the changed files between the given revisions
</summary>
</member>
<member name="T:Fake.Git.FileStatus">

</member>
<member name="M:Fake.Git.Information.getCurrentHash">
<summary>
 Gets the current hash of the current repository
</summary>
</member>
<member name="M:Fake.Git.Information.getLastTag">
<summary>
 Gets the last git tag of the current repository by calling git describe
</summary>
</member>
<member name="M:Fake.Git.Information.shortlog(System.String)">
<summary>
 Gets the git log in one line
</summary>
</member>
<member name="M:Fake.Git.Information.describe(System.String)">
<summary>
 Gets the last git tag by calling git describe
</summary>
</member>
<member name="M:Fake.Git.Information.isAheadOf(System.String,System.String,System.String)">
<summary>
 Returns true if rev1 is ahead of rev2
</summary>
</member>
<member name="M:Fake.Git.Information.showName(System.String,System.String)">
<summary>
 Returns a friendly name from a SHA1
</summary>
</member>
<member name="M:Fake.Git.Information.isCleanWorkingCopy(System.String)">
<summary>
 Checks if the working copy is clean
</summary>
</member>
<member name="M:Fake.Git.Information.showStatus(System.String)">
<summary>
 Shows the git status
</summary>
</member>
<member name="M:Fake.Git.Information.getCurrentSHA1(System.String)">
<summary>
 Returns the SHA1 of the current HEAD
</summary>
</member>
<member name="M:Fake.Git.Information.getVersion(System.String)">
<summary>
 Gets the git version
</summary>
</member>
<member name="M:Fake.Git.Information.getBranchName(System.String)">
<summary>
 Gets the git branch name
</summary>
</member>
<member name="T:Fake.Git.Information">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Git.Merge.merge(System.String,System.String,System.String)">
<summary>
 Performs a merge of the given branch with the current branch
</summary>
</member>
<member name="M:Fake.Git.Merge.compareBranches(System.String,System.String,System.String)">
 <summary>
 Tests whether branches and their "origin" counterparts have diverged and need
 merging first.
 </summary>

 <param name="repositoryDir">The path to the repository.</param>
 <param name="local">The local branch name.</param>
 <param name="remote">The remote branch name.</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Git.Merge.getMergeMessage(System.String)">
<summary>
 Gets the current merge message
</summary>
</member>
<member name="T:Fake.Git.Merge">

</member>
<member name="M:Fake.Git.Rebase.rebaseOrFallbackOnMerge(System.String,System.String)">
 <summary>
 Tries to rebase on top of the given branch.
 If the rebasing process fails a normal merge will be started.
 </summary>
 <returns>If the process used merge instead of rebase.</returns>
</member>
<member name="">

</member>
<member name="M:Fake.Git.Rebase.skip(System.String)">
<summary>
 Restart the rebasing process by skipping the current patch. 
</summary>
</member>
<member name="M:Fake.Git.Rebase.continueRebase(System.String)">
<summary>
 Restart the rebasing process after having resolved a merge conflict. 
</summary>
</member>
<member name="M:Fake.Git.Rebase.abort(System.String)">
<summary>
 Restore the original branch and abort the rebase operation. 
</summary>
</member>
<member name="M:Fake.Git.Rebase.start(System.String,System.String)">
<summary>
 Performs a rebase on top of the given branch with the current branch
</summary>
</member>
<member name="T:Fake.Git.Rebase">

</member>
<member name="M:Fake.Git.Repository.init(System.String,System.Boolean,System.Boolean)">
<summary>
 Inits a git repository
</summary>
</member>
<member name="M:Fake.Git.Repository.clone(System.String,System.String,System.String)">
<summary>
 Clones a git repository
</summary>
</member>
<member name="T:Fake.Git.Repository">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.Git.Reset">

</member>
<member name="M:Fake.Git.SHA1.showObjectHash(System.String,System.String)">
<summary>
 shows the SHA1 calculated by git
</summary>
</member>
<member name="M:Fake.Git.SHA1.calcGitSHA1(System.String)">
<summary>
 Calculates the SHA1 like git
</summary>
</member>
<member name="M:Fake.Git.SHA1.calcSHA1(System.String)">
<summary>
 Calculates the SHA1 for a given string
</summary>
</member>
<member name="T:Fake.Git.SHA1">

</member>
<member name="M:Fake.Git.SanityChecks.checkIsRemoteBranch(System.String,System.String)">
<summary>
 Checks if the given branch is a remote branch.
</summary>
</member>
<member name="M:Fake.Git.SanityChecks.checkIsLocalBranch(System.String,System.String)">
<summary>
 Checks if the given branch is a local branch.
</summary>
</member>
<member name="M:Fake.Git.SanityChecks.checkIfBranchIsAbsent(System.String,System.String)">
<summary>
 Checks if the given branch is absent.
</summary>
</member>
<member name="M:Fake.Git.SanityChecks.checkIfBranchExists(System.String,System.String)">
<summary>
 Checks if the given branch exists.
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.Git.SanityChecks">

</member>
<member name="M:Fake.Git.Staging.StageFile(System.String,System.String)">
<summary>
 Adds a file to the staging area
</summary>
</member>
<member name="T:Fake.Git.Staging">

</member>
<member name="M:Fake.Git.Stash.pop(System.String)">
<summary>
 Remove a single stashed state from the stash list and 
 apply it on top of the current working tree state, 
 i.e., do the inverse operation of git stash save. 
 The working directory must match the index. 
</summary>
</member>
<member name="M:Fake.Git.Stash.push(System.String,System.String)">
<summary>
 Stash the changes in a dirty working directory away.
</summary>
</member>
<member name="T:Fake.Git.Stash">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Git.Submodule.add(System.String,System.String,System.String,System.String)">
 <summary>Adds a submodule to the current repository.</summary>
 <param name="superRepositoryDir">The super repository.</param>
 <param name="remotePath">The path to the remote repository of the submodule.</param>
 <param name="localPath">The local path to the submodule.</param>
 <param name="branch">The branch to  clone. (can be null)</param>
</member>
<member name="M:Fake.Git.Submodule.init(System.String,System.String)">
<summary>
 Inits a submodule
</summary>
</member>
<member name="M:Fake.Git.Submodule.getSubModules(System.String)">
<summary>
 Gets all submodules
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.Git.Submodule">

</member>
<member name="M:Fake.HTMLHelpWorkShopHelper.CompileHTMLHelpProject(System.String,System.String)">
 <summary>Uses the HTML Help Workshop to compile a help project.</summary>
 <param name="helpCompiler">The filename of the HTML Help WorkShop tool</param>
 <param name="projectFile">the fileName of the help project</param>
 <returns>The generated files (fileNames)</returns>
</member>
<member name="T:Fake.HTMLHelpWorkShopHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.HttpClientHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.HttpListenerHelper">

</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.XmlDocs">
<summary>
 True -&gt; XML documentation files are merged to produce an XML documentation file for the target assembly.
</summary>
</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.UnionMerge">
<summary>
 True -&gt; types with the same name are all merged into a single type in the target assembly.
</summary>
</member>
<member name="">

</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.TargetPlatform">
<summary>
 v1 or v1.1 or v2 or v4 or version,platform
</summary>
</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.SearchDirectories">
<summary>
 Directories to be used to search for input assemblies
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.DebugInfo">
<summary>
 True (default) -&gt; creates a .pdb file for the output assembly and merges into it any .pdb files found for input assemblies.
</summary>
</member>
<member name="">

</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.Closed">
<summary>
 True -&gt; transitive closure of the input assemblies is computed and added to the list of input assemblies.
</summary>
</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.AttributeFile">
<summary>
 Path to an assembly that will be used to get all of the assembly-level attributes
</summary>
</member>
<member name="">

</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.AllowWildcards">
<summary>
 Wild cards in file names are expanded and all matching files will be used as input.
</summary>
</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.AllowMultipleAssemblyLevelAttributes">
<summary>
 Assembly-level attributes names that have the same type are copied over into the target directory
</summary>
</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.AllowDuplicateTypes">
<summary>
 Duplicate types policy
</summary>
</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.Libraries">
<summary>
 Assemblies to merge with the primary assembly
</summary>
</member>
<member name="">

</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.Version">
<summary>
 Version to use for the merged assembly
</summary>
</member>
<member name="F:Fake.ILMergeHelper.ILMergeParams.ToolPath">
<summary>
 Path to ILMerge.exe
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.ILMergeHelper.AllowDuplicateTypes.DuplicateTypes">
<summary>
 List of types to allow to be duplicated
</summary>
</member>
<member name="T:Fake.ILMergeHelper.AllowDuplicateTypes.AllPublicTypes">
<summary>
 All public types are allowed to be duplicated and renamed
</summary>
</member>
<member name="T:Fake.ILMergeHelper.AllowDuplicateTypes.NoDuplicateTypes">
<summary>
 No duplicates of public types allowed
</summary>
</member>
<member name="">

</member>
<member name="M:Fake.ILMergeHelper.ILMerge(Microsoft.FSharp.Core.FSharpFunc`2{Fake.ILMergeHelper.ILMergeParams,Fake.ILMergeHelper.ILMergeParams},System.String,System.String)">
<summary>
 Use ILMerge to merge some .NET assemblies.
</summary>
</member>
<member name="M:Fake.ILMergeHelper.getArguments(System.String,System.String,Fake.ILMergeHelper.ILMergeParams)">
<summary>
 Builds the arguments for the ILMerge task
</summary>
</member>
<member name="P:Fake.ILMergeHelper.ILMergeDefaults">
<summary>
 ILMerge default params  
</summary>
</member>
<member name="T:Fake.ILMergeHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Json.deserializeFile``1">
<summary>
 Deserializes a file into a object of type &apos;a
</summary>
</member>
<member name="M:Fake.Json.deserialize``1(System.String)">
<summary>
 Deserializes a text into a object of type &apos;a
</summary>
</member>
<member name="M:Fake.Json.serialize``1(``0)">
<summary>
 Serializes a object to json
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.Json">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.MSBuild.SpecsRemovement.Nothing``2(``0,``1)">
<summary>
 A Convetion which matches nothing
</summary>
</member>
<member name="M:Fake.MSBuild.SpecsRemovement.AllSpecAndTestDataFiles(System.String,System.String)">
<summary>
 All Spec.cs or Spec.fs files and all files containing TestData
</summary>
</member>
<member name="M:Fake.MSBuild.SpecsRemovement.AllSpecFiles``1(``0,System.String)">
<summary>
 All Spec.cs or Spec.fs files
</summary>
</member>
<member name="M:Fake.MSBuild.SpecsRemovement.AllNUnitReferences``1(``0,System.String)">
<summary>
 All references to nunit.*.dlls
</summary>
</member>
<member name="M:Fake.MSBuild.SpecsRemovement.RemoveTestsFromProject(Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.FSharpFunc`2{System.String,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.FSharpFunc`2{System.String,System.Boolean}},System.String)">
 <summary>Removes test data and test files from a given MSBuild project and recursivly from all MSBuild project dependencies</summary>
 <param name="assemblyFilterF">A filter function for assembly references.</param>
 <param name="fileFilterF">A filter function for files in a project.</param>
 <param name="projectFileName">The MSBuild project to start.</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.MSBuild.SpecsRemovement.normalize(System.Xml.Linq.XDocument)">
<summary>
 Converts a MSBuildProject to XML
</summary>
</member>
<member name="T:Fake.MSBuild.SpecsRemovement">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.MSBuildHelper.MSBuildRelease(System.String,System.String)">
<summary>
 Builds the given project files and collects the output files
</summary>
</member>
<member name="M:Fake.MSBuildHelper.MSBuildDebug(System.String,System.String)">
<summary>
 Builds the given project files and collects the output files
</summary>
</member>
<member name="M:Fake.MSBuildHelper.MSBuild(System.String,System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{System.String,System.String}},System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Builds the given project files and collects the output files
</summary>
</member>
<member name="M:Fake.MSBuildHelper.build(Microsoft.FSharp.Core.FSharpFunc`2{Fake.MSBuildHelper.MSBuildParams,Fake.MSBuildHelper.MSBuildParams},System.String)">
<summary>
 Runs a msbuild project
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fake.MSBuildHelper.msBuildExe">
<summary>
 MSBuild exe fileName
</summary>
</member>
<member name="T:Fake.MSBuildHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fake.MSIHelper.MSIDefaults">
<summary>
 MSI default params  
</summary>
</member>
<member name="T:Fake.MSIHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fake.MSpecHelper.MSpecDefaults">
<summary>
 MSpec default params  
</summary>
</member>
<member name="T:Fake.MSpecHelper">

</member>
<member name="M:Fake.MessageHelper.WaitForMessageFile(System.String,System.TimeSpan)">
<summary>
 Waits for another application to create a output file
   - if the timeout is reached an exception will be raised
</summary>
</member>
<member name="M:Fake.MessageHelper.WaitForMessageFiles(System.Collections.Generic.IEnumerable{System.String},System.TimeSpan)">
<summary>
 Waits for other applications to create a output files
 if the timeout is reached an exception will be raised
</summary>
</member>
<member name="T:Fake.MessageHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.NCoverHelper.NCover(Microsoft.FSharp.Core.FSharpFunc`2{Fake.NCoverHelper.NCoverParams,Fake.NCoverHelper.NCoverParams},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
 <summary>Run NCover on a group of assemblies.</summary>
 <param name="setParams">NCover parameter function</param>
 <param name="assemblies">The test assemblies, which should be inspected</param>
 <param name="excludeAssemblies">These assemblies are excluded</param>
</member>
<member name="P:Fake.NCoverHelper.NCoverDefaults">
<summary>
 NCover default params
</summary>
</member>
<member name="T:Fake.NCoverHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.NUnitHelper.writeXMLOutput(Fake.NUnitHelper.TestSuite,System.String)">
<summary>
 writes the given TestSuite as XML file in NUnit style
</summary>
</member>
<member name="M:Fake.NUnitHelper.NUnit(Microsoft.FSharp.Core.FSharpFunc`2{Fake.NUnitHelper.NUnitParams,Fake.NUnitHelper.NUnitParams},System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Run NUnit on a group of assemblies.
</summary>
</member>
<member name="P:Fake.NUnitHelper.NUnitDefaults">
<summary>
 NUnit default params  
</summary>
</member>
<member name="T:Fake.NUnitHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.NuGetHelper.NuGet(Microsoft.FSharp.Core.FSharpFunc`2{Fake.NuGetHelper.NuGetParams,Fake.NuGetHelper.NuGetParams},System.String)">
<summary>
 Creates a new NuGet package   
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.NuGetHelper.GetPackageVersion(System.String,System.String)">
<summary>
 Gets the version no. for a given package in the deployments folder
</summary>
</member>
<member name="">

</member>
<member name="M:Fake.NuGetHelper.NuGetDefaults">
<summary>
 NuGet default params  
</summary>
</member>
<member name="T:Fake.NuGetHelper">

</member>
<member name="M:Fake.Option.toNullable``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Converts an F# option into a nullable object
</summary>
</member>
<member name="M:Fake.Option.fromNullable``1(System.Nullable{``0})">
<summary>
 Converts a nullable object into an F# option
</summary>
</member>
<member name="T:Fake.Option">

</member>
<member name="">

</member>
<member name="T:Fake.PermissionsHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Fake.ProcessHelper.ExecParams.Args">
<summary>
 Command-line argument pairs. The value will be quoted if it contains
 a string, and the result will be appended to the CommandLine property.
 If the key ends in a letter or number, a space will be inserted between
 the key and the value.
</summary>
</member>
<member name="F:Fake.ProcessHelper.ExecParams.CommandLine">
<summary>
 Command-line parameters in a string.
</summary>
</member>
<member name="F:Fake.ProcessHelper.ExecParams.WorkingDirectory">
<summary>
 The working directory for the program. Defaults to &quot;&quot;.
</summary>
</member>
<member name="F:Fake.ProcessHelper.ExecParams.Program">
<summary>
 The path to the executable, without arguments. 
</summary>
</member>
<member name="">

</member>
<member name="P:Fake.ProcessHelper.shellExec">
<summary>
 Execute an external program and return the exit code.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.ProcessHelper.asyncShellExec(Fake.ProcessHelper.ExecParams)">
<summary>
 Execute an external program asynchronously and return the exit code,
 logging output and error messages to FAKE output. You can compose the result
 with Async.Parallel to run multiple external programs at once, but be
 sure that none of them depend on the output of another.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.ProcessHelper.findPath(System.String,System.String)">
<summary>
 Tries to find the tool via AppSettings. If no path has the right tool we are trying the PATH system variable. 
</summary>
</member>
<member name="M:Fake.ProcessHelper.appSettings(System.String)">
<summary>
 Returns the AppSettings for the key - Splitted on ;
</summary>
</member>
<member name="M:Fake.ProcessHelper.findFile(System.Collections.Generic.IEnumerable{System.String},System.String)">
<summary>
 Searches the given directories for the given file, failing if not found
</summary>
</member>
<member name="M:Fake.ProcessHelper.tryFindFile(System.Collections.Generic.IEnumerable{System.String},System.String)">
<summary>
 Searches the given directories for all occurrences of the given file name
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.ProcessHelper.UseDefaults``1">
<summary>
 Use default Parameters
</summary>
</member>
<member name="M:Fake.ProcessHelper.toParam(System.String)">
<summary>
 Adds quotes and a blank around the string   
</summary>
</member>
<member name="M:Fake.ProcessHelper.quoteIfNeeded(System.String)">
<summary>
 Adds quotes around the string if needed
</summary>
</member>
<member name="M:Fake.ProcessHelper.quote(System.String)">
<summary>
 Adds quotes around the string
</summary>
</member>
<member name="M:Fake.ProcessHelper.StartProcess(Microsoft.FSharp.Core.FSharpFunc`2{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit})">
<summary>
 Starts the given process and forgets about it
</summary>
</member>
<member name="M:Fake.ProcessHelper.execProcess(Microsoft.FSharp.Core.FSharpFunc`2{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit},System.TimeSpan)">
<summary>
 Runs the given process
 returns true if the exit code was 0
</summary>
</member>
<member name="M:Fake.ProcessHelper.setEnvironmentVariables(System.Diagnostics.ProcessStartInfo,System.Collections.Generic.IEnumerable{System.Tuple`2{System.String,System.String}})">
<summary>
 sets the environment Settings for the given startInfo
 existing values will be overrriden
</summary>
</member>
<member name="M:Fake.ProcessHelper.ExecProcess(Microsoft.FSharp.Core.FSharpFunc`2{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit},System.TimeSpan)">
<summary>
 Runs the given process
 returns the exit code
</summary>
</member>
<member name="M:Fake.ProcessHelper.execProcess3(Microsoft.FSharp.Core.FSharpFunc`2{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit},System.TimeSpan)">
<summary>
 Runs the given process
 returns if the exit code was 0
</summary>
</member>
<member name="M:Fake.ProcessHelper.execProcessAndReturnExitCode(Microsoft.FSharp.Core.FSharpFunc`2{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit},System.TimeSpan)">
<summary>
 Runs the given process
 returns the exit code
</summary>
</member>
<member name="M:Fake.ProcessHelper.execProcess2(Microsoft.FSharp.Core.FSharpFunc`2{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit},System.TimeSpan,System.Boolean)">
<summary>
 Runs the given process
 returns the exit code
</summary>
</member>
<member name="M:Fake.ProcessHelper.ExecProcessAndReturnMessages(Microsoft.FSharp.Core.FSharpFunc`2{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit},System.TimeSpan)">
<summary>
 Runs the given process and returns the exit code
</summary>
</member>
<member name="M:Fake.ProcessHelper.ExecProcessWithLambdas(Microsoft.FSharp.Core.FSharpFunc`2{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit},System.TimeSpan,System.Boolean,Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Runs the given process and returns the exit code
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.ProcessHelper.Event">

</member>
<member name="T:Fake.ProcessHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.REST.ExecutePostCommand(Microsoft.FSharp.Core.FSharpFunc`2{System.Net.WebHeaderCollection,Microsoft.FSharp.Core.Unit},System.String,System.String,System.String,System.String)">
 <summary>Executes an HTTP POST command and retrives the information.    
 This function will automatically include a "source" parameter if the "Source" property is set.</summary>
 <param name="headerF">The client information to perform the POST operation.</param>
 <param name="url">The URL to perform the POST operation</param>
 <param name="userName">The username to use with the request</param>
 <param name="password">The password to use with the request</param>
 <param name="data">The data to post</param>
 <returns> The response of the request, or null if we got 404 or nothing.</returns>
</member>
<member name="M:Fake.REST.ExecuteGetCommand(System.String,System.String,System.String)">
 <summary>Executes an HTTP GET command and retrives the information.</summary>    
 <param name="userName">The username to use with the request</param>
 <param name="password">The password to use with the request</param>
 <param name="url">The URL to perform the GET operation</param>
 <returns>The response of the request, or null if we got 404 or nothing.</returns>
</member>
<member name="T:Fake.REST">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.RegAsmHelper.RegAsm(Microsoft.FSharp.Core.FSharpFunc`2{Fake.RegAsmHelper.RegAsmParams,Fake.RegAsmHelper.RegAsmParams},System.String)">
<summary>
 Runs regasm on the given lib
</summary>
</member>
<member name="P:Fake.RegAsmHelper.RegAsmDefaults">
<summary>
 RegAsm default params  
</summary>
</member>
<member name="T:Fake.RegAsmHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.RegistryHelper.getRegistryValue(Fake.RegistryHelper.RegistryBaseKey,System.String,System.String)">
<summary>
 gets a registy value as string
</summary>
</member>
<member name="M:Fake.RegistryHelper.getRegistryKey(Fake.RegistryHelper.RegistryBaseKey,System.String)">
<summary>
 gets a registy key
</summary>
</member>
<member name="M:Fake.RegistryHelper.getKey(Fake.RegistryHelper.RegistryBaseKey)">
<summary>
 Maps the RegistryBaseKey to a RegistryKey
</summary>
</member>
<member name="T:Fake.RegistryHelper">

</member>
<member name="M:Fake.SCPHelper.SCP(Microsoft.FSharp.Core.FSharpFunc`2{Fake.SCPParams,Fake.SCPParams},System.String,System.String)">
 <summary>Performs a SCP copy.</summary>
 <param name="source">The source directory (fileName)</param>
 <param name="destination">The target directory (fileName)</param>
</member>
<member name="P:Fake.SCPHelper.SCPDefaults">
<summary>
 SCP default params  
</summary>
</member>
<member name="T:Fake.SCPHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.Seq.contains``1(``0)">
<summary>
 Returns true if the given element exists in the sequence
</summary>
</member>
<member name="T:Fake.Seq">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.ServiceControllerHelpers">

</member>
<member name="">

</member>
<member name="M:Fake.StringHelper.trimSeparator(System.String)">
<summary>
 Trims the given string with the DirectorySeparatorChar
</summary>
</member>
<member name="M:Fake.StringHelper.isLetterOrDigit(System.Char)">
<summary>
 Checks wether the given char is a standard char or digit.
</summary>
</member>
<member name="P:Fake.StringHelper.charsAndDigits">
<summary>
 Returns all standard chars and digits.
</summary>
</member>
<member name="M:Fake.StringHelper.isUmlaut(System.Char)">
<summary>
 Checks wether the given char is a german umlaut.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.StringHelper.toRelativePath(System.String)">
<summary>
 Replaces the absolute path to a relative
</summary>
</member>
<member name="M:Fake.StringHelper.ProduceRelativePath(System.String,System.String)">
 <summary>Produces relative path when possible to go from baseLocation to targetLocation.</summary>
 <param name="baseLocation">The root folder</param>
 <param name="targetLocation">The target folder</param>
 <returns>The relative path relative to baseLocation</returns>
 <exception cref="ArgumentNullException">base or target locations are null or empty</exception>
</member>
<member name="P:Fake.StringHelper.relativePaths">
<summary>
 A cache of relative path names.
</summary>
</member>
<member name="P:Fake.StringHelper.directorySeparator">
<summary>
 The directory separator string. On most systems / or \
</summary>
</member>
<member name="M:Fake.StringHelper.appendFileNamesIfNotNull(System.Collections.Generic.IEnumerable{System.String},System.Text.StringBuilder)">
<summary>
 Appends all notnull fileNames
</summary>
</member>
<member name="M:Fake.StringHelper.appendStringIfValueIsNotNullOrEmpty(System.String)">
<summary>
 Appends a text if the value is not null or empty
</summary>
</member>
<member name="M:Fake.StringHelper.appendStringIfValueIsNotNull``1(``0)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:Fake.StringHelper.appendIfNotNull``1(``0,System.String)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:Fake.StringHelper.appendIfFalse(System.Boolean)">
<summary>
 Appends a text if the predicate is false
</summary>
</member>
<member name="M:Fake.StringHelper.appendIfTrue(System.Boolean,System.String,System.Text.StringBuilder)">
<summary>
 Appends a text if the predicate is true
</summary>
</member>
<member name="M:Fake.StringHelper.append(System.String,System.Text.StringBuilder)">
<summary>
 Appends a text
</summary>
</member>
<member name="M:Fake.StringHelper.EncapsulateApostrophe(System.String)">
<summary>
 Encapsulates the Apostrophe
</summary>
</member>
<member name="M:Fake.StringHelper.RemoveLineBreaks(System.String)">
<summary>
 Removes linebreaks from the given string
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.StringHelper.ReplaceInFile(Microsoft.FSharp.Core.FSharpFunc`2{System.String,System.String},System.String)">
<summary>
 Replaces the text in the given file
</summary>
</member>
<member name="P:Fake.StringHelper.endsWithSlash">
<summary>
 Determines whether the last character of the given &lt;see cref=&quot;string&quot; /&gt;
 matches Path.DirectorySeparatorChar.         
</summary>
</member>
<member name="M:Fake.StringHelper.endsWith(System.String,System.String)">
<summary>
 Checks wether the given text ends with the given suffix
</summary>
</member>
<member name="M:Fake.StringHelper.op_LessMultiply(System.String,System.String)">
<summary>
 Checks wether the given text starts with the given prefix
</summary>
</member>
<member name="M:Fake.StringHelper.startsWith(System.String,System.String)">
<summary>
 Checks wether the given text starts with the given prefix
</summary>
</member>
<member name="M:Fake.StringHelper.toLines(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Converts a sequence of strings into a string separated with line ends
</summary>
</member>
<member name="M:Fake.StringHelper.split(System.Char,System.String)">
<summary>
 Splits the given string at the given delimiter
</summary>
</member>
<member name="M:Fake.StringHelper.trimSlash(System.String)">
<summary>
 Removes the slashes from the end of the given string
</summary>
</member>
<member name="M:Fake.StringHelper.shortenCurrentDirectory(System.String)">
<summary>
 Replaces any occurence of the currentDirectory with .
</summary>
</member>
<member name="M:Fake.StringHelper.ReadFileAsBytes(System.String)">
<summary>
 Reads a file as one array of bytes
</summary>
</member>
<member name="M:Fake.StringHelper.ReadFileAsString(System.String)">
<summary>
 Reads a file as one text
</summary>
</member>
<member name="M:Fake.StringHelper.separated(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Converts a sequence of strings to a string with delimiters
</summary>
</member>
<member name="M:Fake.StringHelper.replace(System.String,System.String,System.String)">
<summary>
 Replaces the given pattern in the given text with the replacement
</summary>
</member>
<member name="M:Fake.StringHelper.AppendToFile(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Appends all lines to a file line by line
</summary>
</member>
<member name="M:Fake.StringHelper.WriteFile(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Writes a file line by line
</summary>
</member>
<member name="">

</member>
<member name="M:Fake.StringHelper.ReplaceFile(System.String,System.String)">
<summary>
 Replaces the file with the given string
</summary>
</member>
<member name="M:Fake.StringHelper.WriteStringToFile(System.Boolean,System.String,System.String)">
<summary>
 Writes string to a file
</summary>
</member>
<member name="M:Fake.StringHelper.WriteBytesToFile(System.String,System.Byte[])">
<summary>
 Writes a byte array to a file
</summary>
</member>
<member name="M:Fake.StringHelper.NormalizeVersion(System.String)">
<summary>
 Removes all trailing .0 from a version string
</summary>
</member>
<member name="M:Fake.StringHelper.WriteToFile(System.Boolean,System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Writes a file line by line
</summary>
</member>
<member name="M:Fake.StringHelper.ReadFile(System.String)">
<summary>
 Reads a file line by line
</summary>
</member>
<member name="P:Fake.StringHelper.isNotNullOrEmpty">
<summary>
 Returns if the string is not null or empty
</summary>
</member>
<member name="M:Fake.StringHelper.isNullOrEmpty(System.String)">
<summary>
 Returns if the string is null or empty
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.StringHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.TargetHelper.ActivateFinalTarget(System.String)">
<summary>
 Activates the FinalTarget
</summary>
</member>
<member name="M:Fake.TargetHelper.FinalTarget(System.String,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Registers a final target (not activated)
</summary>
</member>
<member name="M:Fake.TargetHelper.run(System.String)">
 <summary>Runs a target and its dependencies</summary>
 <param name="targetName">The target to run.</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.TargetHelper.WriteTaskTimeSummary``1(``0)">
 <summary>Writes a build time report.</summary>
 <param name="total">The total runtime.</param>
</member>
<member name="M:Fake.TargetHelper.PrintDependencyGraph(System.Boolean,System.String)">
 <summary>Writes a dependency graph.</summary>
 <param name="verbose">Whether to print verbose output or not.</param>
 <param name="target">The target for which the dependencies should be printed.</param>
</member>
<member name="M:Fake.TargetHelper.runFinalTargets">
<summary>
 Runs all activated final targets (in alphabetically order)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.TargetHelper.Target(System.String,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a Target
</summary>
</member>
<member name="M:Fake.TargetHelper.TargetTemplate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a TargetTemplate      
</summary>
</member>
<member name="M:Fake.TargetHelper.TargetTemplateWithDependecies``1(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a TargetTemplate with dependencies
</summary>
</member>
<member name="M:Fake.TargetHelper.targetFromTemplate``1(Fake.TargetHelper.TargetTemplate{``0},System.String,``0)">
<summary>
 Creates a target from template
</summary>
</member>
<member name="M:Fake.TargetHelper.AllTargetsDependOn(System.String)">
<summary>
 Set a dependency for all registered targets
</summary>
</member>
<member name="M:Fake.TargetHelper.TargetsDependOn(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Set a dependency for all given targets
</summary>
</member>
<member name="M:Fake.TargetHelper.op_LessEqualsEquals(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Dependencies operator
</summary>
</member>
<member name="M:Fake.TargetHelper.Dependencies(System.String)">
<summary>
 Adds the dependencies to the list of dependencies  
</summary>
</member>
<member name="P:Fake.TargetHelper.dependency">
<summary>
 Adds the dependency to the list of dependencies
</summary>
</member>
<member name="M:Fake.TargetHelper.dependencyAtEnd(System.String,System.String)">
<summary>
 Appends the dependency to the list of dependencies
</summary>
</member>
<member name="M:Fake.TargetHelper.dependencyAtFront(System.String,System.String)">
<summary>
 Adds the dependency to the front of the list of dependencies
</summary>
</member>
<member name="M:Fake.TargetHelper.checkIfDependencyCanBeAdded(System.String,System.String)">
<summary>
 Checks wether the dependency can be add
</summary>
</member>
<member name="M:Fake.TargetHelper.DoNothing">
<summary>
 Do nothing - fun () -&gt; ()   
</summary>
</member>
<member name="M:Fake.TargetHelper.getAllTargetsNames">
<summary>
 Returns a list with all targetNames
</summary>
</member>
<member name="M:Fake.TargetHelper.dependencyString``1(Fake.TargetHelper.TargetTemplate{``0})">
<summary>
 Returns the DependencyString for the given target
</summary>
</member>
<member name="M:Fake.TargetHelper.getTarget(System.String)">
<summary>
 Gets a target with the given name from the target dictionary
</summary>
</member>
<member name="P:Fake.TargetHelper.ExecutedTargetTimes">
<summary>
 The executed target time
</summary>
</member>
<member name="P:Fake.TargetHelper.ExecutedTargets">
<summary>
 The executed targets
</summary>
</member>
<member name="P:Fake.TargetHelper.FinalTargets">
<summary>
 Final Targets - stores final target and if it is activated
</summary>
</member>
<member name="P:Fake.TargetHelper.TargetDict">
<summary>
 TargetDictionary  
</summary>
</member>
<member name="M:Fake.TargetHelper.Description(System.String)">
<summary>
 Sets the Description for the next target
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.TargetHelper">

</member>
<member name="M:Fake.TeamCityHelper.getChangedFilesInCurrentBuild">
<summary>
 Gets the changed files
</summary>
</member>
<member name="M:Fake.TeamCityHelper.getRecentlyFailedTests">
<summary>
 Gets the recently failed tests
</summary>
</member>
<member name="M:Fake.TeamCityHelper.ComparisonFailure(System.String,System.String,System.String,System.String,System.String)">
<summary>
 Reports a failed comparison.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.TestFailed(System.String,System.String,System.String)">
<summary>
 Reports a failed test.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.SetBuildStatistic(System.String,System.String)">
<summary>
 Reports a build statistic.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.SetBuildNumber(System.String)">
<summary>
 Sets the TeamCity build number.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.PublishArticfact(System.String)">
<summary>
 Publishes an artifact on the TeamcCity build server.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.ReportBuildStatus(System.String,System.String)">
<summary>
 Reports the build status.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.ReportProgressFinish(System.String)">
<summary>
 Reports the progress end.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.ReportProgressStart(System.String)">
<summary>
 Reports the progress start.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.ReportProgress(System.String)">
<summary>
 Reports the progress.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.StartTestSuite(System.String)">
<summary>
 Starts the test suite.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.FinishTestSuite(System.String)">
<summary>
 Finishes the test suite.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.IgnoreTestCase(System.String,System.String)">
<summary>
 Ignores the test case.      
</summary>
</member>
<member name="M:Fake.TeamCityHelper.FinishTestCase(System.String,System.TimeSpan)">
<summary>
 Finishes the test case.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.StartTestCase(System.String)">
<summary>
 Starts the test case.
</summary>
</member>
<member name="M:Fake.TeamCityHelper.sendTeamCityFXCopImport(System.String)">
<summary>
 Sends an FXCop results filename to TeamCity    
</summary>
</member>
<member name="M:Fake.TeamCityHelper.sendTeamCityNUnitImport(System.String)">
<summary>
 Sends an NUnit results filename to TeamCity
</summary>
</member>
<member name="M:Fake.TeamCityHelper.sendTeamCityError(System.String)">
<summary>
 Sends an error to TeamCity
</summary>
</member>
<member name="M:Fake.TeamCityHelper.sendStrToTeamCity(System.String)">
<summary>
 Send message to TeamCity
</summary>
</member>
<member name="M:Fake.TeamCityHelper.sendToTeamCity(Microsoft.FSharp.Core.PrintfFormat{Microsoft.FSharp.Core.FSharpFunc`2{System.String,System.String},Microsoft.FSharp.Core.Unit,System.String,System.String},System.String)">
<summary>
 Send message to TeamCity
</summary>
</member>
<member name="M:Fake.TeamCityHelper.EncapsulateSpecialChars(System.String)">
<summary>
 Encapsulates special chars
</summary>
</member>
<member name="T:Fake.TeamCityHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.TeamCityRESTHelper.getProjects(System.String,System.String,System.String)">
<summary>
 Gets all projects on the TeamCity 
</summary>
</member>
<member name="M:Fake.TeamCityRESTHelper.getProject(System.String,System.String,System.String,System.String)">
<summary>
 Gets a projects from the TeamCity server
</summary>
</member>
<member name="M:Fake.TeamCityRESTHelper.getBuildConfig(System.String,System.String,System.String,System.String)">
<summary>
 Gets a projects from the TeamCity server
</summary>
</member>
<member name="">

</member>
<member name="M:Fake.TeamCityRESTHelper.getRESTVersion(System.String,System.String,System.String)">
<summary>
 Returns the REST version of the TeamCity server
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.TeamCityRESTHelper">

</member>
<member name="M:Fake.TemplateHelper.processTemplates(System.Collections.Generic.IEnumerable{System.Tuple`2{System.String,System.String}},System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Replaces the templates with the given replacements
</summary>
</member>
<member name="P:Fake.TemplateHelper.saveFiles">
<summary>
 saves all files (lazy - file by file!)
</summary>
</member>
<member name="M:Fake.TemplateHelper.replaceKeywords``2(System.Collections.Generic.IEnumerable{System.Tuple`2{System.String,System.String}})">
<summary>
 replaces a bunch of the keywords in all files (lazy - line by line!)
</summary>
</member>
<member name="M:Fake.TemplateHelper.loadTemplates(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Loads all templates (lazy - line by line!)    
</summary>
</member>
<member name="T:Fake.TemplateHelper">

</member>
<member name="M:Fake.TimeoutHelper.waitFor(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Boolean},System.TimeSpan,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Waits until the given function returns true or the timeout is reached
</summary>
</member>
<member name="T:Fake.TimeoutHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.TraceHelper.traceEndTask(System.String,System.String)">
<summary>
 Traces the end of a task
</summary>
</member>
<member name="M:Fake.TraceHelper.traceStartTask(System.String,System.String)">
<summary>
 Traces the begin of a task
</summary>
</member>
<member name="M:Fake.TraceHelper.traceEndTarget(System.String)">
<summary>
 Traces the end of a target   
</summary>
</member>
<member name="M:Fake.TraceHelper.traceStartTarget(System.String,System.String,System.String)">
<summary>
 Traces the begin of a target
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.TraceHelper.traceEndBuild">
<summary>
 Traces the end of the build
</summary>
</member>
<member name="M:Fake.TraceHelper.traceStartBuild">
<summary>
 Traces the begin of the build
</summary>
</member>
<member name="M:Fake.TraceHelper.traceHeader(System.String)">
<summary>
 Traces a header
</summary>
</member>
<member name="M:Fake.TraceHelper.traceLine">
<summary>
 Traces a line
</summary>
</member>
<member name="P:Fake.TraceHelper.fakeVersionStr">
<summary>
 Gets the FAKE Version string
</summary>
</member>
<member name="M:Fake.TraceHelper.TraceEnvironmentVariables">
<summary>
 Traces the EnvironmentVariables
</summary>
</member>
<member name="M:Fake.TraceHelper.traceError(System.String)">
<summary>
 Traces an error (in red)
</summary>
</member>
<member name="M:Fake.TraceHelper.traceFAKE``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Writes a trace to the command line (in yellow)
</summary>
</member>
<member name="M:Fake.TraceHelper.traceImportant(System.String)">
<summary>
 Writes a trace to stderr (in yellow)  
</summary>
</member>
<member name="M:Fake.TraceHelper.traceVerbose(System.String)">
<summary>
 Writes a trace to the command line (in green) if the verbose mode is activated.
</summary>
</member>
<member name="M:Fake.TraceHelper.tracef``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Writes a message to the command line (in green) and without a line break
</summary>
</member>
<member name="M:Fake.TraceHelper.tracefn``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Writes a message to the command line (in green)
</summary>
</member>
<member name="M:Fake.TraceHelper.trace(System.String)">
<summary>
 Writes a trace to the command line (in green)
</summary>
</member>
<member name="M:Fake.TraceHelper.logVerbosefn``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Logs the specified string if the verbose mode is activated.
</summary>
</member>
<member name="M:Fake.TraceHelper.logf``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Logs the specified message (without line break)
</summary>
</member>
<member name="M:Fake.TraceHelper.logfn``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Logs the specified message
</summary>
</member>
<member name="M:Fake.TraceHelper.log(System.String)">
<summary>
 Logs the specified string        
</summary>
</member>
<member name="">

</member>
<member name="P:Fake.TraceHelper.fakeVersion">
<summary>
 Gets the FAKE version no.
</summary>
</member>
<member name="P:Fake.TraceHelper.fakePath">
<summary>
 Gets the path of the current FAKE instance
</summary>
</member>
<member name="T:Fake.TraceHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.TraceListener.NAntXmlTraceListener.Fake-TraceListener-ITraceListener-Write(Fake.TraceListener.TraceData)">
<summary>
 Writes the given message to the xml file.
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.TraceListener.NAntXmlTraceListener">
 <summary>Implements a TraceListener which writes NAnt like XML files.</summary>
 <param name="xmlOutputFile">Defines the xml output file.</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.TraceListener.ConsoleTraceListener.Fake-TraceListener-ITraceListener-Write(Fake.TraceListener.TraceData)">
<summary>
 Writes the given message to the Console.
</summary>
</member>
<member name="">

</member>
<member name="T:Fake.TraceListener.ConsoleTraceListener">
 <summary>Implements a TraceListener for System.Console</summary>
 <param name="importantMessagesToStdErr">Defines whether to trace important messages to StdErr.</param>
 <param name="colorMap">A function which maps TracePriorities to ConsoleColors.</param>
</member>
<member name="">

</member>
<member name="T:Fake.TraceListener.ITraceListener">
<summary>
 Defines a TraceListener interface
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.TraceListener.TraceData">
<summary>
 Defines Tracing information for TraceListeners
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fake.TraceListener.defaultConsoleTraceListener">
<summary>
 The default TraceListener for Console
</summary>
</member>
<member name="M:Fake.TraceListener.colorMap(Fake.TraceListener.TraceData)">
<summary>
 Maps TracePriorities to ConsoleColors
</summary>
</member>
<member name="T:Fake.TraceListener">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.VSSHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fake.WiXHelper.WiX(Microsoft.FSharp.Core.FSharpFunc`2{Fake.WiXHelper.WiXParams,Fake.WiXHelper.WiXParams},System.String,System.String)">
<summary>
 Uses Candle and Light to create a msi.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fake.WiXHelper.WiXDefaults">
<summary>
 WiX default params  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fake.WiXHelper">

</member>
<member name="M:Fake.XCopyHelper.XCopy(System.String,System.String)">
 <summary>Performs a XCopy.</summary>
 <param name="source">The source directory (fileName)</param>
 <param name="destination">The target directory (fileName)</param>
</member>
<member name="T:Fake.XCopyHelper">

</member>
<member name="M:Fake.XMLHelper.XmlPokeNS(System.String,System.Collections.Generic.IEnumerable{System.Tuple`2{System.String,System.String}},System.String,System.String)">
<summary>
 Replaces text in an XML file at the location specified by an XPath expression, with support for namespaces.
</summary>
</member>
<member name="M:Fake.XMLHelper.XPathReplaceNS``1(System.String,System.String,``0,System.Xml.XmlDocument)">
<summary>
 Replaces text in XML document specified by an XPath expression, with support for namespaces.
</summary>
</member>
<member name="M:Fake.XMLHelper.XmlPoke(System.String,System.String,System.String)">
<summary>
 Replaces text in an XML file at the location specified by an XPath expression.
</summary>
</member>
<member name="M:Fake.XMLHelper.XPathValue``1(System.String,``0,System.Xml.XmlDocument)">
<summary>
 Selects and xml nodes value via xpath from the given document
</summary>
</member>
<member name="M:Fake.XMLHelper.XPathReplace(System.String,System.String,System.Xml.XmlDocument)">
<summary>
 Replaces text in XML document specified by an XPath expression.
</summary>
</member>
<member name="M:Fake.XMLHelper.DocElement(System.Xml.XmlDocument)">
<summary>
 Gets the DocumentElement of the XmlDocument
</summary>
</member>
<member name="M:Fake.XMLHelper.XMLDoc(System.String)">
<summary>
 Gets the result as xml
</summary>
</member>
<member name="M:Fake.XMLHelper.parseSubNode``1(System.String,Microsoft.FSharp.Core.FSharpFunc`2{System.Xml.XmlNode,``0})">
<summary>
 parses a subnode
</summary>
</member>
<member name="M:Fake.XMLHelper.parse``2(System.String,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0)">
<summary>
 parses a node
</summary>
</member>
<member name="M:Fake.XMLHelper.getSubNode(System.String)">
<summary>
 gets the sub node with the name
</summary>
</member>
<member name="M:Fake.XMLHelper.getChilds``1(``0)">
<summary>
 Gets the child nodes for the given nodes
</summary>
</member>
<member name="M:Fake.XMLHelper.getAttribute``1(System.String,``0)">
<summary>
 Gets the attribute with the given name 
</summary>
</member>
<member name="M:Fake.XMLHelper.XmlCDataElement(System.String,System.String,System.Xml.XmlTextWriter)">
<summary>
 Writes an CData element  
</summary>
</member>
<member name="M:Fake.XMLHelper.XmlAttribute``1(System.String,``0,System.Xml.XmlTextWriter)">
<summary>
 Writes an Xml attribute
</summary>
</member>
<member name="M:Fake.XMLHelper.XmlEndElement(System.Xml.XmlTextWriter)">
<summary>
 Writes an Xml element end
</summary>
</member>
<member name="M:Fake.XMLHelper.XmlStartElement(System.String,System.Xml.XmlTextWriter)">
<summary>
 Writes an Xml element start
</summary>
</member>
<member name="M:Fake.XMLHelper.XmlComment(System.String,System.Xml.XmlTextWriter)">
<summary>
 Writes an Xml comment      
</summary>
</member>
<member name="M:Fake.XMLHelper.XmlWriter(System.String)">
<summary>
 Generates an XmlWriter    
</summary>
</member>
<member name="M:Fake.XMLHelper.XMLRead_Int(System.Boolean,System.String,System.String,System.String,System.String)">
<summary>
 Reads a value from a XML document using a XPath
 returns if the value is an int and the value
</summary>
</member>
<member name="M:Fake.XMLHelper.XMLRead(System.Boolean,System.String,System.String,System.String,System.String)">
<summary>
 Reads a value from a XML document using a XPath
</summary>
</member>
<member name="T:Fake.XMLHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fake.XUnitHelper.XUnitDefaults">
<summary>
 xUnit default params  
</summary>
</member>
<member name="T:Fake.XUnitHelper">

</member>
<member name="M:Fake.ZipHelper.UnzipFirstMatchingFileInMemory(Microsoft.FSharp.Core.FSharpFunc`2{ICSharpCode.SharpZipLib.Zip.ZipEntry,System.Boolean},System.String)">
 <summary>Unzips a single file from the archive with the given fileName.</summary>
 <param name="predicate">The predictae for the searched file in the archive.</param>
 <param name="zipFileName">The FileName of the zip file.</param>
</member>
<member name="M:Fake.ZipHelper.UnzipSingleFileInMemory(System.String,System.String)">
 <summary>Unzips a single file from the archive with the given fileName.</summary>
 <param name="fileToUnzip">The file inside the archive.</param>
 <param name="zipFileName">The FileName of the zip file.</param>
</member>
<member name="M:Fake.ZipHelper.Unzip(System.String,System.String)">
 <summary>Unzips a file with the given fileName.</summary>
 <param name="target">The target directory.</param>
 <param name="fileName">The fileName of the zip file.</param>
</member>
<member name="M:Fake.ZipHelper.ZipFile(System.String,System.String)">
 <summary>Creates a zip file with the given file.</summary>
 <param name="fileName">The fileName of the resulting zip file.</param>
 <param name="targetFileName">The file to zip.</param>
</member>
<member name="M:Fake.ZipHelper.Zip(System.String,System.String)">
 <summary>Creates a zip file with the given files.</summary>
 <param name="workingDir">The relative dir of the zip files. Use this parameter to influence directory structure within zip file.</param>
 <param name="fileName">The fileName of the resulting zip file.</param>
 <param name="files">A sequence with files to zip.</param>
</member>
<member name="M:Fake.ZipHelper.CreateZip(System.String,System.String,System.String,System.Int32,System.Boolean,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Creates a zip file with the given files
</summary>
</member>
<member name="P:Fake.ZipHelper.DefaultZipLevel">
<summary>
 The default zip level
</summary>
</member>
<member name="T:Fake.ZipHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FakeLib.AssemblyInfo">

</member>
</members>
</doc>
