<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Castle.MicroKernel</name>
    </assembly>
    <members>
        <member name="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator">
            <summary>
            Abstract implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>.
            The implementors must only override the InternalCreate and 
            InternalDestroy methods in order to perform their creation and
            destruction logic.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IComponentActivator">
            <summary>
            Implements the instance creation logic. The default
            implementation should rely on an ordinary call to 
            Activator.CreateInstance(). 
            </summary>
            <remarks>
            This interface is provided in order to allow custom components
            to be created using a different logic, such as using a specific factory
            or builder.
            <para>
            The constructor for implementation has the following signature:
            </para>
            <code>
            ComponentModel model, IKernel kernel, 
            ComponentInstanceDelegate onCreation, 
            ComponentInstanceDelegate onDestruction
            </code>
            <para>
            The Activator should raise the events onCreation and onDestruction
            in order to correctly implement the contract. Usually the best
            way of creating a custom activator is by extending the existing ones.
            </para>
            <seealso cref="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator"/>
            <seealso cref="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator"/>
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IComponentActivator.Create(Castle.MicroKernel.CreationContext)">
            <summary>
            Should return a new component instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IComponentActivator.Destroy(System.Object)">
            <summary>
            Should perform all necessary work to dispose the instance
            and/or any resource related to it.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Constructs an AbstractComponentActivator
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.ComponentActivatorException">
            <summary>
            Summary description for ComponentActivatorException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator">
            <summary>
            Standard implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>.
            Handles the selection of the best constructor, fills the
            writable properties the component exposes, run the commission 
            and decommission lifecycles, etc.
            </summary>
            <remarks>
            Custom implementors can just override the <c>CreateInstance</c> method.
            Please note however that the activator is responsible for the proxy creation
            when needed.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator"/> class.
            </summary>
            <param name="model"></param>
            <param name="kernel"></param>
            <param name="onCreation"></param>
            <param name="onDestruction"></param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator">
            <summary>
            Attempts to dynamically load a UserControl by invoking Page.LoadControl.  
            There are two uses of this class.  
            <para>
            1) Add a component to the Kernel and add a VirtualPath attribute specifying 
            the relative path of the .ascx file for the associated UserControl. (easy)
            </para>
            <example>
              <code>
                &lt;component id="BasketView" 
                  service="Castle.ShoppingCart.IBasketView, Castle.ShoppingCart"
                  type="Castle.ShoppingCart.BasketView, Castle.ShoppingCart" 
                  lifestyle="transient"
                  virtualPath="~/Views/BasketView.ascx"
                /&gt;
              </code>
            </example>
            <para>
            2) Precompile a UserControl and add the pre-compiled class to the Kernel. (hard)  
            Has not been tested with proxies.
            </para>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The on creation.</param>
            <param name="onDestruction">The on destruction.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator.CreateInstance(Castle.MicroKernel.CreationContext,System.Object[],System.Type[])">
            <summary>
            Creates the instance.
            </summary>
            <param name="context">The context.</param>
            <param name="arguments">The arguments.</param>
            <param name="signature">The signature.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Burden">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.CreationContext">
            <summary>
            Used during a component request, passed along to the whole process.
            This allow some data to be passed along the process, which is used 
            to detected cycled dependency graphs and now it's also being used
            to provide arguments to components.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ISubDependencyResolver">
            <summary>
            Implementors should use a strategy to obtain 
            valid references to properties and/or services 
            requested in the dependency model.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ISubDependencyResolver.Resolve(Castle.MicroKernel.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Should return an instance of a service or property values as
            specified by the dependency model instance. 
            It is also the responsability of <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            to throw an exception in the case a non-optional dependency 
            could not be resolved.
            </summary>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="contextHandlerResolver">Parent resolver - normally the IHandler implementation</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns>The dependency resolved value or null</returns>
        </member>
        <member name="M:Castle.MicroKernel.ISubDependencyResolver.CanResolve(Castle.MicroKernel.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Returns true if the resolver is able to satisfy this dependency.
            </summary>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="contextHandlerResolver">Parent resolver - normally the IHandler implementation</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns><c>true</c> if the dependency can be satisfied</returns>
        </member>
        <member name="F:Castle.MicroKernel.CreationContext.dependencies">
            <summary>
            Holds the scoped dependencies being resolved. 
            If a dependency appears twice on the same scope, we'd have a cycle.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.CreationContext.handlerStack">
            <summary>
            The list of handlers that are used to resolve
            the component.
            We track that in order to try to avoid attempts to resolve a service
            with itself.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.CreationContext.#ctor(System.Type,Castle.MicroKernel.CreationContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.CreationContext"/> class.
            </summary>
            <param name="typeToExtractGenericArguments">The type to extract generic arguments.</param>
            <param name="parentContext">The parent context.</param>
        </member>
        <member name="M:Castle.MicroKernel.CreationContext.#ctor(Castle.MicroKernel.IHandler,Castle.MicroKernel.IReleasePolicy,System.Type,System.Collections.IDictionary,Castle.MicroKernel.SubSystems.Conversion.ITypeConverter)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.CreationContext"/> class.
            </summary>
            <param name="handler">The handler.</param>
            <param name="releasePolicy">The release policy.</param>
            <param name="typeToExtractGenericArguments">The type to extract generic arguments.</param>
            <param name="additionalArguments">The additional arguments.</param>
            <param name="conversionManager">The conversion manager.</param>
        </member>
        <member name="M:Castle.MicroKernel.CreationContext.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.CreationContext"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.CreationContext.IsInResolutionContext(Castle.MicroKernel.IHandler)">
            <summary>
            Method used by handlers to test whether they are being resolved in the context.
            </summary>
            <param name="handler"></param>
            <returns></returns>
            <remarks>
            This method is provided as part of double dispatch mechanism for use by handlers.
            Outside of handlers, call <see cref="M:Castle.MicroKernel.IHandler.IsBeingResolvedInContext(Castle.MicroKernel.CreationContext)"/> instead.
            </remarks>
        </member>
        <member name="P:Castle.MicroKernel.CreationContext.Empty">
            <summary>Creates a new, empty <see cref="T:Castle.MicroKernel.CreationContext"/> instance.</summary>
            <remarks>A new CreationContext should be created every time, as the contexts keeps some state related to dependency resolution.</remarks>
        </member>
        <member name="P:Castle.MicroKernel.CreationContext.Handler">
            <summary>
            Pendent
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.DependencyTrackingScope.DependencyModelExtended">
            <summary>
            Extends <see cref="T:Castle.Core.DependencyModel"/> adding <see cref="T:System.Reflection.MemberInfo"/> and <see cref="T:Castle.Core.ComponentModel"/>
            information. Th MemberInfo is only useful to provide detailed information 
            on exceptions. 
            The ComponentModel is required so we can get resolve an object that takes as a parameter itself, but
            with difference model. (See IoC 51 for the details)
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Exceptions.CircularDependencyException">
            <summary>
            Exception throw when a circular dependency is detected
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Exceptions.CircularDependencyException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Exceptions.CircularDependencyException"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Exceptions.CircularDependencyException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Exceptions.CircularDependencyException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.Exceptions.CircularDependencyException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Exceptions.CircularDependencyException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.Exceptions.CircularDependencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Exceptions.CircularDependencyException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is <see langword="null"/>.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is <see langword="null"/> or <see cref="P:System.Exception.HResult"/> is zero (0).</exception>
        </member>
        <member name="T:Castle.MicroKernel.ComponentNotFoundException">
            <summary>
            Exception threw when a request for a component
            cannot be satisfied because the component does not
            exist in the container
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/> class.
            </summary>
            <param name="service">The service.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentNotFoundException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentRegistrationException">
            <summary>
            Exception threw when there is a problem
            registering a component
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ComponentRegistrationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentRegistrationException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentRegistrationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentRegistrationException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.KernelException">
            <summary>
            Exception threw by Kernel operations that failed
            for some reason.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.KernelException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.KernelException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.KernelException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.Facilities.EventWiring.EventWiringException">
            <summary>
            Exception that is thrown when a error occurs during the Event Wiring process
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Facilities.FacilityException">
            <summary>
            Base exception to be used by facilities.
            </summary>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.Facilities.EventWiring.EventWiringFacility">
             <summary>
             Facility to allow components to dynamically subscribe to events offered by 
             other components. We call the component that offers events publishers and 
             the components that uses them, subscribers.
             </summary>
             <remarks>
             A component that wish to subscribe to an event must use the external configuration
             adding a node <c>subscribers</c> on the publisher. This node can have multiple entries using the 
             <c>subscriber</c> node.
             </remarks>
             <example>
             <para>This example shows two simple components: one is the event publisher and the other is the 
             subscriber. The subscription will be done by the facility, using the publisher associated configuration.</para>
             <para>The Publisher class:</para>
             <code>
             public class SimplePublisher
            	{
            		public event PublishEventHandler Event;
            
            		public void Trigger()
            		{
            			if (Event != null)
            			{
            				Event(this, new EventArgs()); 
            			}
            		}
             }
             </code>
             <para>The Subscriber class:</para>
             <code>
             public class SimpleListener
             {
             	private bool _listened;
             	private object _sender;
             
             	public void OnPublish(object sender, EventArgs e)
             	{
             		_sender = sender; 
             		_listened = sender != null;
             	}
             
             	public bool Listened
             	{
             		get { return _listened;	}
             	}
             
             	public object Sender
             	{
             		get { return _sender; }
             	}
             }
             </code>
             <para>The configuration file:</para>
             <code>
             <![CDATA[
             <?xml version="1.0" encoding="utf-8" ?>
             <configuration>
             	<facilities>
             		<facility 
             			id="event.wiring"
             			type="Castle.Facilities.EventWiring.EventWiringFacility, Castle.MicroKernel" />
             	</facilities>
             
             	<components>
             		<component 
             			id="SimpleListener" 
             			type="Castle.Facilities.EventWiring.Tests.Model.SimpleListener, Castle.Facilities.EventWiring.Tests" />
             
             		<component 
             			id="SimplePublisher" 
             			type="Castle.Facilities.EventWiring.Tests.Model.SimplePublisher, Castle.Facilities.EventWiring.Tests" >
             			<subscribers>
             				<subscriber id="SimpleListener" event="Event" handler="OnPublish"/>
             			</subscribers>
             		</component>
             	</components>
             </configuration>
             ]]>
             </code>
             </example>
        </member>
        <member name="T:Castle.MicroKernel.Facilities.AbstractFacility">
            <summary>
            Base class for facilities. 
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IFacility">
            <summary>
            Unit of extension. A facility should use 
            the extension points offered by the kernel
            to augment its functionality.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IFacility.Init(Castle.MicroKernel.IKernel,Castle.Core.Configuration.IConfiguration)">
            <summary>
            
            </summary>
            <param name="kernel"></param>
            <param name="facilityConfig"></param>
        </member>
        <member name="M:Castle.MicroKernel.IFacility.Terminate">
            <summary>
            
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Init">
            <summary>
            The custom initialization for the Facility.
            </summary>
            <remarks>It must be overriden.</remarks>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Init(Castle.MicroKernel.IKernel,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Initializes the facility. First it performs the initialization common for all 
            facilities, setting the <see cref="P:Castle.MicroKernel.Facilities.AbstractFacility.Kernel"/> and the 
            <see cref="P:Castle.MicroKernel.Facilities.AbstractFacility.FacilityConfig"/>. After it, the <c>Init</c> method is invoked
            and the custom initilization is perfomed.
            </summary>
            <param name="kernel"></param>
            <param name="facilityConfig"></param>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Terminate">
            <summary>
            Terminates the Facility, invokes the <see cref="M:Castle.MicroKernel.Facilities.AbstractFacility.Dispose"/> method and sets 
            the Kernel to a null reference.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Dispose">
            <summary>
            Performs the tasks associated with freeing, releasing, or resetting 
            the facility resources.
            </summary>
            <remarks>It can be overriden.</remarks>
        </member>
        <member name="P:Castle.MicroKernel.Facilities.AbstractFacility.Kernel">
            <summary>
            Gets the <see cref="T:Castle.MicroKernel.IKernel"/> where the facility is registered.
            </summary>
            <value>The <see cref="T:Castle.MicroKernel.IKernel"/>.</value>
        </member>
        <member name="P:Castle.MicroKernel.Facilities.AbstractFacility.FacilityConfig">
            <summary>
            Gets the facility configuration.
            </summary>
            <value>The <see cref="T:Castle.Core.Configuration.IConfiguration"/> representing 
            the facility configuration.</value>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.Init">
            <summary>
            Overriden. Initializes the facility, subscribing to the <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentModelCreated"/>,
            <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentCreated"/>, <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentDestroyed"/> Kernel events.
            </summary>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.OnComponentModelCreated(Castle.Core.ComponentModel)">
            <summary>
            Checks if the component we're dealing is a publisher. If it is, 
            parses the configuration (the subscribers node) getting the event wiring info.
            </summary>
            <param name="model">The component model.</param>
            <exception cref="T:Castle.Facilities.EventWiring.EventWiringException">Invalid and/or a error in the configuration</exception>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.OnComponentCreated(Castle.Core.ComponentModel,System.Object)">
            <summary>
            Checks if the component we're dealing is a publisher. If it is, 
            iterates the subscribers starting them and wiring the events.
            </summary>
            <param name="model">The component model.</param>
            <param name="instance">The instance representing the component.</param>
            <exception cref="T:Castle.Facilities.EventWiring.EventWiringException">When the subscriber is not found
            <br/> or <br/>
            The handler method isn't found
            <br/> or <br/>
            The event isn't found
            </exception>
        </member>
        <member name="T:Castle.Facilities.EventWiring.WireInfo">
            <summary>
            Represents the information about an event.
            </summary>
        </member>
        <member name="M:Castle.Facilities.EventWiring.WireInfo.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.WireInfo"/> class.
            </summary>
            <param name="eventName">Name of the event.</param>
            <param name="handler">The name of the handler method.</param>
        </member>
        <member name="M:Castle.Facilities.EventWiring.WireInfo.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="M:Castle.Facilities.EventWiring.WireInfo.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"></see> to compare with the current <see cref="T:System.Object"></see>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>; otherwise, false.
            </returns>
        </member>
        <member name="P:Castle.Facilities.EventWiring.WireInfo.EventName">
            <summary>
            Gets the name of the event.
            </summary>
            <value>The name of the event.</value>
        </member>
        <member name="P:Castle.Facilities.EventWiring.WireInfo.Handler">
            <summary>
            Gets the handler method name.
            </summary>
            <value>The handler.</value>
        </member>
        <member name="T:Castle.Facilities.FactorySupport.FactoryActivator">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.Facilities.Remoting.RemoteActivator">
            <summary>
            Activates a object connecting to the remote server.
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemoteActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemoteActivator"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The oncreation event handler.</param>
            <param name="onDestruction">The ondestruction event handler.</param>
        </member>
        <member name="T:Castle.Facilities.Remoting.RemoteActivatorThroughConnector">
            <summary>
            Activates a client connecting to the remote server, enforcing the uri and the server activation.
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemoteActivatorThroughConnector.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemoteActivatorThroughConnector"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The oncreation event handler.</param>
            <param name="onDestruction">The ondestruction event handler.</param>
        </member>
        <member name="T:Castle.Facilities.Remoting.RemoteActivatorThroughRegistry">
            <summary>
            Activates a client connecting to the remote server through the <see cref="T:Castle.Facilities.Remoting.RemotingRegistry"/>.
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemoteActivatorThroughRegistry.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemoteActivatorThroughRegistry"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The oncreation envent handler.</param>
            <param name="onDestruction">The ondestruction event handler.</param>
        </member>
        <member name="T:Castle.Facilities.Remoting.RemoteClientActivatedActivator">
            <summary>
            Activates a client activated object.
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemoteClientActivatedActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemoteClientActivatedActivator"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The oncreation event handler.</param>
            <param name="onDestruction">The ondestruction event handler.</param>
        </member>
        <member name="T:Castle.Facilities.Remoting.RemoteMarshallerActivator">
            <summary>
            Activates and publishes a server object.
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemoteMarshallerActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemoteMarshallerActivator"/> class.
            </summary>
            <param name="model">The model.</param>
            <param name="kernel">The kernel.</param>
            <param name="onCreation">The oncreation event handler.</param>
            <param name="onDestruction">The ondestruction event handler.</param>
        </member>
        <member name="T:Castle.Facilities.Remoting.RemotingFacility">
            <summary>
            Facility to allow the communication with remote kernel, using the .NET Remoting infraestructure.
            </summary>
            <remarks>
            TODO
            </remarks>
            <example>
            TODO
            </example>
        </member>
        <member name="F:Castle.Facilities.Remoting.RemotingFacility.baseUri">
            <summary>
            Used for client side (Expand explanation)
            </summary>
        </member>
        <member name="F:Castle.Facilities.Remoting.RemotingFacility.localRegistry">
            <summary>
            Used for server side. 
            Holds the local registry
            </summary>
        </member>
        <member name="F:Castle.Facilities.Remoting.RemotingFacility.remoteRegistry">
            <summary>
            Used for client side. 
            Holds a remote proxy to the server registry
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingFacility.#ctor">
            <summary>
            Constructs a RemotingFacility
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingFacility.Dispose">
            <summary>
            Performs the tasks associated with freeing, releasing, or resetting
            the facility resources.
            </summary>
            <remarks>It can be overriden.</remarks>
        </member>
        <member name="T:Castle.Facilities.Remoting.RemotingInspector">
            <summary>
            Inspects the model looking for remote component configuration. If found, 
            do the component Remoting configuration.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction">
            <summary>
            Implementors must inspect the component for 
            a given information or parameter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Usually the implementation will look in the configuration property 
            of the model or the service interface, or the implementation looking for
            something.
            </summary>
            <param name="kernel">The kernel instance</param>
            <param name="model">The component model</param>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingInspector.#ctor(Castle.MicroKernel.SubSystems.Conversion.ITypeConverter,System.Boolean,System.Boolean,System.String,Castle.Facilities.Remoting.RemotingRegistry,Castle.Facilities.Remoting.RemotingRegistry)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.Facilities.Remoting.RemotingInspector"/> class.
            </summary>
            <param name="converter">The converter.</param>
            <param name="isServer">if set to <c>true</c> is a server.</param>
            <param name="isClient">if set to <c>true</c> is a client.</param>
            <param name="baseUri">The base URI.</param>
            <param name="remoteRegistry">The remote registry.</param>
            <param name="localRegistry">The local registry.</param>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingInspector.ResetDependencies(Castle.Core.ComponentModel)">
            <summary>
            Client components are not created by the container
            so there's no point collecting constructor dependencies
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingRegistry.GetModel(System.Type)">
            <summary>
            Used in case of generics:
            </summary>
            <param name="serviceType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.CheckWaitingList">
            <summary>
            For each new component registered,
            some components in the WaitingDependency
            state may have became valid, so we check them
            </summary>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.Start(System.String)">
            <summary>
            Request the component instance
            </summary>
            <param name="key"></param>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.ILifecycleConcern">
            <summary>
            Represents a concern that will be applied to a component instance
            during commission or decomission phase. 
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.LifecycleConcerns.ILifecycleConcern.Apply(Castle.Core.ComponentModel,System.Object)">
            <summary>
            Implementors should act on the instance in response to 
            a decomission or commission phase. 
            </summary>
            <param name="model">The model.</param>
            <param name="component">The component.</param>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.TypedFactory.ITypedFactoryComponentSelector.SelectComponent(System.Reflection.MethodInfo,System.Type,System.Object[])">
            <summary>
            Selects one or both of component name and type, for given method 
            called on given typed factory type.
            When component should be requested by type only,
            componentName should be null.
            When component should be requested by name only,
            componentType should be null.
            
            </summary>
            <param name="method"></param>
            <param name="type"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Facilities.TypedFactory.ITypedFactoryMethod.Invoke(Castle.Core.Interceptor.IInvocation)">
            <summary>
            Performs actual invocation of typed factory method.
            </summary>
            <param name="invocation"></param>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.FactoryInterceptor">
            <summary>
            Summary description for FactoryInterceptor.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Facilities.TypedFactory.Release">
            <summary>
            Releases components passed as arguments from the container.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Facilities.TypedFactory.Resolve">
            <summary>
            resolves componet selected by given <see cref="T:Castle.MicroKernel.Facilities.TypedFactory.ITypedFactoryComponentSelector"/> from the container
            </summary>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.TypedFactoryFacility">
            <summary>
            Summary description for TypedFactoryFacility.
            </summary>
        </member>
        <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0})">
            <summary>
            Marks the component as typed factory.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="registration"></param>
            <returns></returns>
            <remarks>
            Only interfaces are legal to use as typed factories. Methods with out parameters are not allowed.
            When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
            Typed factories rely on <see cref="T:Castle.Core.Interceptor.IInterceptorSelector"/> set internally, so users should not set interceptor selectors explicitly;
            otherwise the factory will not function correctly.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.AbstractHandler">
            <summary>
            Implements the basis of <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IHandler">
            <summary>
            Contract for the IHandler, which manages an
            component state and coordinates its creation 
            and destruction (dispatching to activators, lifestyle managers)
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Init(Castle.MicroKernel.IKernel)">
            <summary>
            Initializes the handler with a reference to the
            kernel.
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Resolve(Castle.MicroKernel.CreationContext)">
            <summary>
            Implementors should return a valid instance 
            for the component the handler is responsible.
            It should throw an exception in the case the component
            can't be created for some reason
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Release(System.Object)">
            <summary>
            Implementors should dispose the component instance
            </summary>
            <param name="instance"></param>
            <returns>true if destroyed.</returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.AddCustomDependencyValue(System.String,System.Object)">
            <summary>
            Dictionary of String/object used to 
            associate data with a component dependency.
            For example, if you component SmtpServer depends on 
            host and port, you can add those to this
            dictionary and the handler will be able to use them.
            </summary>
            <remarks>
            TODO: Document this
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.RemoveCustomDependencyValue(System.String)">
            <summary>
            TODO: Document this
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.HasCustomParameter(System.String)">
            <summary>
            TODO: Document this
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.IsBeingResolvedInContext(Castle.MicroKernel.CreationContext)">
            <summary>
            Tests whether the handler is already being resolved in given context.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IHandler.CurrentState">
            <summary>
            Gets the state of the handler
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IHandler.ComponentModel">
            <summary>
            Gets the model of the component being 
            managed by this handler.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IHandler.Service">
            <summary>
            The serivce that this handler handles
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IHandler.OnHandlerStateChanged">
            <summary>
            Allow to track state changes of a handler that is modified directly.
            This can happen if the client calls AddCustomDependencyValue or 
            RemoveCustomDependencyValue
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.IExposeDependencyInfo">
            <summary>
            Might be implemented by a handler 
            so it can expose access to dependency information 
            which is used to construct meaningful error messages
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.IExposeDependencyInfo.ObtainDependencyDetails(System.Collections.IList)">
            <summary>
            Returns human readable list of dependencies 
            this handler is waiting for.
            <param name="dependenciesChecked">list of the dependecies that was already checked, used to avoid cycles.</param>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.dependenciesByService">
            <summary>
            Dictionary of Type to a list of <see cref="T:Castle.Core.DependencyModel"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.dependenciesByKey">
            <summary>
            Dictionary of key (string) to <see cref="T:Castle.Core.DependencyModel"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.customParameters">
            <summary>
            Custom dependencies values associated with the handler
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.lifestyleManager">
            <summary>
            Lifestyle manager instance
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.#ctor(Castle.Core.ComponentModel)">
            <summary>
            Constructs and initializes the handler
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Init(Castle.MicroKernel.IKernel)">
            <summary>
            Saves the kernel instance, subscribes to 
            <see cref="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel"/> event,
            creates the lifestyle manager instance and computes
            the handler state.
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Resolve(Castle.MicroKernel.CreationContext)">
            <summary>
            Returns an instance of the component this handler
            is responsible for
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.ResolveCore(Castle.MicroKernel.CreationContext,System.Boolean)">
            <summary>
            Should be implemented by derived classes: 
            returns an instance of the component this handler
            is responsible for
            </summary>
            <param name="context"></param>
            <param name="track"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Release(System.Object)">
            <summary>
             disposes the component instance (or recycle it).
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.ReleaseCore(System.Object)">
            <summary>
            Should be implemented by derived classes: 
            disposes the component instance (or recycle it)
            </summary>
            <param name="instance"></param>
            <returns>true if destroyed.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.AddCustomDependencyValue(System.String,System.Object)">
            <summary>
            TODO: Pendent
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.HasCustomParameter(System.String)">
            <summary>
            TODO: Pendent
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.RemoveCustomDependencyValue(System.String)">
            <summary>
            TODO: Pendent
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.ObtainDependencyDetails(System.Collections.IList)">
            <summary>
            Returns human readable list of dependencies 
            this handler is waiting for.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.CreateLifestyleManager(Castle.MicroKernel.IComponentActivator)">
            <summary>
            Creates an implementation of <see cref="T:Castle.MicroKernel.ILifestyleManager"/> based
            on <see cref="T:Castle.Core.LifestyleType"/> and invokes <see cref="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)"/>
            to initialize the newly created manager.
            </summary>
            <param name="activator"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.EnsureDependenciesCanBeSatisfied">
            <summary>
            Checks if the handler is able to, at very least, satisfy
            the dependencies for the constructor with less parameters
            </summary>
            <remarks>
            For each non*optional dependency, the implementation will invoke 
            <see cref="M:Castle.MicroKernel.Handlers.AbstractHandler.AddDependency(Castle.Core.DependencyModel)"/>
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.AddDependency(Castle.Core.DependencyModel)">
            <summary>
            Invoked by <see cref="M:Castle.MicroKernel.Handlers.AbstractHandler.EnsureDependenciesCanBeSatisfied"/>
            in order to check if a dependency can be satisfied.
            If not, the handler is set to a 'waiting dependency' state.
            </summary>
            <remarks>
            This method registers the dependencies within the correct collection 
            or dictionary and changes the handler state to 
            <see cref="F:Castle.MicroKernel.HandlerState.WaitingDependency"/>
            </remarks>
            <param name="dependency"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.DependencySatisfied(System.Boolean@)">
            <summary>
            Invoked by the kernel
            when one of registered dependencies were satisfied by 
            new components registered.
            </summary>
            <remarks>
            Handler for the event <see cref="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered"/>
            </remarks>
            <param name="stateChanged"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.OnAddedAsChildKernel(System.Object,System.EventArgs)">
            <summary>
            Invoked when the container receives a parent container reference.
            </summary>
            <remarks>
            This method implementation checks whether the parent container
            is able to supply the dependencies for this handler.
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.HandlerStateChanged(System.Object,System.EventArgs)">
            <summary>
            Handler for the event <see cref="E:Castle.MicroKernel.Handlers.AbstractHandler.OnHandlerStateChanged"/>
            </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="P:Castle.MicroKernel.Handlers.AbstractHandler.CurrentState">
            <summary>
            Gets the handler state.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Handlers.AbstractHandler.ComponentModel">
            <summary>
            Gets the component model.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.Handlers.AbstractHandler.OnHandlerStateChanged">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultGenericHandler">
            <summary>
            Summary description for DefaultGenericHandler.
            </summary>
            <remarks>
            TODO: Consider refactoring AbstractHandler moving lifestylemanager
            creation to DefaultHandler
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultGenericHandler.#ctor(Castle.Core.ComponentModel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.DefaultGenericHandler"/> class.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultGenericHandler.CloneParentProperties(Castle.Core.ComponentModel)">
            <summary>
            Clone some of the parent componentmodel properties to the generic subhandler.
            </summary>
            <remarks>
            The following properties are copied:
            <list type="bullet">
            <item>
            	<description>The <see cref="T:Castle.Core.LifestyleType"/></description>
            </item>
            <item>
            	<description>The <see cref="P:Castle.Core.ComponentModel.Interceptors"/></description>
            </item>
            </list>
            </remarks>
            <param name="newModel">the subhandler</param>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultHandler">
            <summary>
            Summary description for DefaultHandler.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.#ctor(Castle.Core.ComponentModel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.DefaultHandler"/> class.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.ResolveCore(Castle.MicroKernel.CreationContext,System.Boolean)">
            <summary>
            Returns an instance of the component this handler
            is responsible for
            </summary>
            <param name="context"></param>
            <param name="track"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.ReleaseCore(System.Object)">
            <summary>
            disposes the component instance (or recycle it)
            </summary>
            <param name="instance"></param>
            <returns>true if destroyed</returns>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultHandlerFactory">
            <summary>
            Summary description for DefaultHandlerFactory.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IHandlerFactory">
            <summary>
            Extension point to allow the developer
            to use his implementation of <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.HandlerException">
            <summary>
            Summary description for HandlerException.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.HandlerException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.HandlerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.HandlerState">
            <summary>
            Possible states for a IHandler instance
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.HandlerState.Valid">
            <summary>
            The component can be requested
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.HandlerState.WaitingDependency">
            <summary>
            The component can not be requested 
            as it still depending on a external 
            dependency not yet available
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.HandlerStateDelegate">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="args"></param>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.ParentHandlerWithChildResolver">
            <summary>
            Redirects resolution to the main resolver, and if not found uses
            the parent handler.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.ParentHandlerWithChildResolver.#ctor(Castle.MicroKernel.IHandler,Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.ParentHandlerWithChildResolver"/> class.
            </summary>
            <param name="parentHandler">The parent handler.</param>
            <param name="childResolver">The child resolver.</param>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.DisposalConcern">
            <summary>
            Summary description for DisposalConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.InitializationConcern">
            <summary>
            Summary description for InitializationConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.SupportInitializeConcern">
            <summary>
            Summary description for SupportInitializeConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.Pool.IPool">
            <summary>
            Pool implementation contract. 
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.IPool.Request(Castle.MicroKernel.CreationContext)">
            <summary>
            Implementors should return a component instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.IPool.Release(System.Object)">
            <summary>
            Implementors should release the instance or put it
            on the pool
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.DefaultPool.InitPool">
            <summary>
            Initializes the pool to a initial size by requesting
            n components and then releasing them.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.AbstractLifestyleManager">
            <summary>
            Summary description for AbstractLifestyleManager.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ILifestyleManager">
            <summary>
            The <c>ILifestyleManager</c> implements 
            a strategy for a given lifestyle, like singleton, perthread
            and transient.
            </summary>
            <remarks>
            The responsability of <c>ILifestyleManager</c>
            is only the management of lifestyle. It should rely on
            <see cref="T:Castle.MicroKernel.IComponentActivator"/> to obtain a new component instance
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Initializes the <c>ILifestyleManager</c> with the 
            <see cref="T:Castle.MicroKernel.IComponentActivator"/>
            </summary>
            <param name="componentActivator"></param>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Resolve(Castle.MicroKernel.CreationContext)">
            <summary>
            Implementors should return the component instance based 
            on the lifestyle semantic.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Release(System.Object)">
            <summary>
            Implementors should release the component instance based
            on the lifestyle semantic, for example, singleton components
            should not be released on a call for release, instead they should
            release them when disposed is invoked.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PerThreadLifestyleManager">
            <summary>
            Summary description for PerThreadLifestyleManager.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.PerThreadLifestyleManager.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PerThreadThreadStaticLifestyleManager">
            <summary>
            per thread LifestyleManager implementation compatibile with Silverlight.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.PerThreadThreadStaticLifestyleManager.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PerWebRequestLifestyleManager">
            <summary>
            Implements a Lifestyle Manager for Web Apps that
            create at most one object per web request.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PoolableLifestyleManager">
            <summary>
            Implements a Poolable Lifestyle Manager. 
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.SingletonLifestyleManager">
            <summary>
            Summary description for SingletonLifestyleManager.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.TransientLifestyleManager">
            <summary>
            Summary description for TransientLifestyleManager.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector">
            <summary>
            Inspects the component configuration and the type looking for a
            definition of component activator type. The configuration preceeds whatever
            is defined in the component.
            </summary>
            <remarks>
            This inspector is not guarantee to always set up an component activator type. 
            If nothing could be found it wont touch the model. In this case is up to
            the kernel to establish a default component activator for components.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Seaches for the component activator in the configuration and, if unsuccessful
            look for the component activator attribute in the implementation type.
            </summary>
            <param name="kernel">The kernel instance</param>
            <param name="model">The model instance</param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ReadComponentActivatorFromConfiguration(Castle.Core.ComponentModel)">
            <summary>
            Reads the attribute "componentActivatorType" associated with the 
            component configuration and verifies it implements the <see cref="T:Castle.MicroKernel.IComponentActivator"/> 
            interface. 
            </summary>
            <exception cref="T:System.Exception">
            If the type does not implement the proper interface
            </exception>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ReadComponentActivatorFromType(Castle.Core.ComponentModel)">
            <summary>
            Check if the type expose one of the component activator attributes
            defined in Castle.Core namespace.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ValidateComponentActivator(System.Type)">
            <summary>
            Validates that the provide type implements IComponentActivator
            </summary>
            <param name="customComponentActivator">The custom component activator.</param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector">
            <summary>
            Inspects the component configuration and type looking for information
            that can influence the generation of a proxy for that component.
            <para>
            We specifically look for <c>useSingleInterfaceProxy</c> and <c>marshalByRefProxy</c> 
            on the component configuration or the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute"/> 
            attribute.
            </para>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Seaches for proxy behavior in the configuration and, if unsuccessful
            look for the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute"/> attribute in 
            the implementation type.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector.ReadProxyBehavior(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Reads the proxy behavior associated with the 
            component configuration/type and applies it to the model.
            </summary>
            <exception cref="T:System.Exception">
            If the conversion fails
            </exception>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector.GetProxyBehaviorFromType(System.Type)">
            <summary>
            Returns a <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute"/> instance if the type
            uses the attribute. Otherwise returns null.
            </summary>
            <param name="implementation"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector">
            <summary>
            Uses the ConfigurationStore registered in the kernel to obtain
            an <see cref="T:Castle.Core.Configuration.IConfiguration"/> associated with the component.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Queries the kernel's ConfigurationStore for a configuration
            associated with the component name.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector">
            <summary>
            Check for a node 'parameters' within the component 
            configuration. For each child it, a ParameterModel is created
            and added to ComponentModel's Parameters collection
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Inspect the configuration associated with the component
            and populates the parameter model collection accordingly
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConstructorDependenciesModelInspector">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction"/>
            collects all available constructors and populates them in the model
            as candidates. The Kernel will pick up one of the candidates
            according to a heuristic.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ExtendedPropertiesConstants">
            <summary>
            Only to hold internal constants and get rid of 
            magic numbers and hardcode names.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.InterceptorInspector">
            <summary>
            Inspect the component for <c>InterceptorAttribute</c> and
            the configuration for the interceptors node
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector">
            <summary>
            Inspects the type looking for interfaces that constitutes
            lifecycle interfaces, defined in the Castle.Model namespace.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Checks if the type implements <see cref="T:Castle.Core.IInitializable"/> and or
            <see cref="T:System.IDisposable"/> interfaces.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector">
            <summary>
            Inspects the component configuration and the type looking for a
            definition of lifestyle type. The configuration preceeds whatever
            is defined in the component.
            </summary>
            <remarks>
            This inspector is not guarantee to always set up an lifestyle type. 
            If nothing could be found it wont touch the model. In this case is up to
            the kernel to estabish a default lifestyle for components.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Seaches for the lifestyle in the configuration and, if unsuccessful
            look for the lifestyle attribute in the implementation type.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromConfiguration(Castle.Core.ComponentModel)">
            <summary>
            Reads the attribute "lifestyle" associated with the 
            component configuration and tries to convert to <see cref="T:Castle.Core.LifestyleType"/>  
            enum type. 
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromType(Castle.Core.ComponentModel)">
            <summary>
            Check if the type expose one of the lifestyle attributes
            defined in Castle.Model namespace.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector">
            <summary>
            Base for inspectors that want configuration associated with methods.
            For each child a <see cref="T:Castle.Core.MethodMetaModel"/> is created
            and added to ComponentModel's methods collection
            </summary>
            <remarks>
            Implementors should override the <see cref="M:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector.ObtainNodeName"/> return
            the name of the node to be inspected. For example:
            <code>
            <![CDATA[
              <transactions>
                <method name="Save" transaction="requires" />
              </transactions>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction"/>
            collects all potential writable puplic properties exposed by the component 
            implementation and populates the model with them.
            The Kernel might be able to set some of these properties when the component 
            is requested.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Adds the properties as optional dependencies of this component.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder">
            <summary>
            Summary description for DefaultComponentModelBuilder.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IComponentModelBuilder">
            <summary>
            Implementors must construct a populated
            instance of ComponentModel by inspecting the component
            and|or the configuration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.BuildModel(System.String,System.Type,System.Type,System.Collections.IDictionary)">
            <summary>
            Constructs a new ComponentModel by invoking
            the registered contributors.
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <param name="classType"></param>
            <param name="extendedProperties"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.AddContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
            "To give or supply in common with others; give to a 
            common fund or for a common purpose". The contributor
            should inspect the component, or even the configuration
            associated with the component, to add or change information
            in the model that can be used later.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.RemoveContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
            Removes the specified contributor
            </summary>
            <param name="contributor"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.#ctor(Castle.MicroKernel.IKernel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder"/> class.
            </summary>
            <param name="kernel">The kernel.</param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.BuildModel(System.String,System.Type,System.Type,System.Collections.IDictionary)">
            <summary>
            Constructs a new ComponentModel by invoking
            the registered contributors.
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <param name="classType"></param>
            <param name="extendedProperties"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.AddContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
            "To give or supply in common with others; give to a
            common fund or for a common purpose". The contributor
            should inspect the component, or even the configuration
            associated with the component, to add or change information
            in the model that can be used later.
            </summary>
            <param name="contributor"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.RemoveContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
            Removes the specified contributor
            </summary>
            <param name="contributor"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.InitializeContributors">
            <summary>
            Initializes the default contributors.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.Contributors">
            <summary>
            Gets the contributors.
            </summary>
            <value>The contributors.</value>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.IModelInterceptorsSelector">
            <summary>
            Select the appropriate interecptors based on the application specific
            business logic
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.IModelInterceptorsSelector.SelectInterceptors(Castle.Core.ComponentModel)">
            <summary>
            Select the appropriate intereceptor references.
            The intereceptor references aren't neccessarily registered in the model.Intereceptors
            </summary>
            <param name="model">The model to select the interceptors for</param>
            <returns>The intereceptors for this model (in the current context) or a null reference</returns>
            <remarks>
            If the selector is not interested in modifying the interceptors for this model, it 
            should return a null reference and the next selector in line would be executed (or the default
            model.Interceptors).
            If the selector return a non null value, this is the value that is used, and the model.Interectors are ignored, if this
            is not the desirable behavior, you need to merge your interceptors with the ones in model.Interecptors yourself.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.IModelInterceptorsSelector.HasInterceptors(Castle.Core.ComponentModel)">
            <summary>
            Determain whatever the specified has interecptors.
            The selector should only return true from this method if it has determained that is
            a model that it would likely add interceptors to.
            </summary>
            <param name="model">The model</param>
            <returns>Whatever this selector is likely to add intereceptors to the specified model</returns>
        </member>
        <member name="T:Castle.MicroKernel.IProxyFactory">
            <summary>
            Defines the contract used by the kernel 
            to obtain proxies for components. The implementor
            must return a proxied instance that dispatch 
            the invocation to the registered interceptors in the model
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,Castle.MicroKernel.CreationContext,System.Object[])">
            <summary>
            Implementors must create a proxy based on 
            the information exposed by ComponentModel
            </summary>
            <param name="kernel">The kernel instance</param>
            <param name="model">The component model</param>
            <param name="instance">The component instance to be proxy (only required in some cases)</param>
            <param name="constructorArguments">array of parameters to the constructor (if any)</param>
            <param name="context">The creation context</param>
            <returns>proxy instance</returns>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.RequiresTargetInstance(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Implementor should check the component model
            and determine if the caller must pass on the component 
            instance to the proxy
            </summary>
            <param name="kernel">The kernel instance</param>
            <param name="model">The component model</param>
            <returns><c>true</c> if an instance must be passed to <see cref="M:Castle.MicroKernel.IProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,Castle.MicroKernel.CreationContext,System.Object[])"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.AddInterceptorSelector(Castle.MicroKernel.Proxy.IModelInterceptorsSelector)">
            <summary>
            Add the selector to the list of selectors that can affect interecptors decisions
            in the container.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.ShouldCreateProxy(Castle.Core.ComponentModel)">
            <summary>
            Determains whatever we need to create a proxy for this model
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.IProxyHook">
            <summary>
            Used during the target type inspection process.
            Implementors have a chance to interfere in the
            proxy generation process
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.IProxyHook.ShouldInterceptMethod(System.Type,System.Reflection.MethodInfo)">
            <summary>
            Invoked by the generation process to know if
            the specified member should be proxied
            </summary>
            <param name="type"></param>
            <param name="memberInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.IProxyHook.NonVirtualMemberNotification(System.Type,System.Reflection.MemberInfo)">
            <summary>
            Invoked by the generation process to notify that a
            member wasn't marked as virtual.
            </summary>
            <param name="type"></param>
            <param name="memberInfo"></param>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.IProxyHook.MethodsInspected">
            <summary>
            Invoked by the generation process to notify 
            that the whole process is completed.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.NotSupportedProxyFactory">
            <summary>
            This is a placeholder implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>.
            </summary>
            <remarks>
            The decision to supply no implementation for <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            is supported by the fact that the MicroKernel should be a thin
            assembly with the minimal set of features, although extensible.
            Providing the support for this interface would obligate 
            the user to import another assembly, even if the large majority of
            simple cases, no use use of interceptors will take place.
            If you want to use however, see the Windsor container.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.ProxyConstants">
            <summary>
            Holds the keys used by the proxy factories.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.Proxy.ProxyConstants.ProxyOptionsKey">
            <summary>
            Key used to supply custom proxy options.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.ProxyOptions">
            <summary>
            Represents options to configure proxies.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Proxy.ProxyOptions"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.AddAdditionalInterfaces(System.Type[])">
            <summary>
            Adds the additional interfaces to proxy.
            </summary>
            <param name="interfaces">The interfaces.</param>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.AddMixIns(System.Object[])">
            <summary>
            Adds the additional mix ins to integrate.
            </summary>
            <param name="mixIns">The mix ins.</param>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.Equals(System.Object)">
            <summary>
            Equalses the specified obj.
            </summary>
            <param name="obj">The obj.</param>
            <returns>true if equal.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.GetHashCode">
            <summary>
            Gets the hash code.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.Hook">
            <summary>
            Gets or sets the proxy hook.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.Selector">
            <summary>
            Gets or sets the interceptor selector.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.OmitTarget">
            <summary>
            Determines if the proxied component uses a target.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.AllowChangeTarget">
            <summary>
            Determines if the proxied component can change targets.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.UseSingleInterfaceProxy">
            <summary>
            Determines if the proxied component should only include
            the service interface.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.UseMarshalByRefAsBaseClass">
            <summary>
            Determines if the interface proxied component should inherit 
            from <see cref="T:System.MarshalByRefObject"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.AdditionalInterfaces">
            <summary>
            Gets the additional interfaces to proxy.
            </summary>
            <value>The interfaces.</value>
        </member>
        <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.MixIns">
            <summary>
            Gets the mix ins to integrate.
            </summary>
            <value>The interfaces.</value>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.ProxyUtil">
            <summary>
            Helper support for proxy configuration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Proxy.ProxyUtil.ObtainProxyOptions(Castle.Core.ComponentModel,System.Boolean)">
            <summary>
            Obtains the <see cref="T:Castle.MicroKernel.Proxy.ProxyOptions"/> associated with the <see cref="T:Castle.Core.ComponentModel"/>.
            </summary>
            <param name="model">The component model.</param>
            <param name="createOnDemand">true if the options should be created if not present.</param>
            <returns>The associated proxy options for the component model.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Is(Castle.Core.LifestyleType)">
            <summary>
            Sets the lifestyle to the specified <paramref name="type"/>.
            </summary>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Custom(System.Type)">
            <summary>
            Assign a custom lifestyle type, that implements <see cref="T:Castle.MicroKernel.ILifestyleManager"/>.
            </summary>
            <param name="customLifestyleType">Type of the custom lifestyle.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Custom``1">
            <summary>
            Assign a custom lifestyle type, that implements <see cref="T:Castle.MicroKernel.ILifestyleManager"/>.
            </summary>
            <typeparam name="L">The type of the custom lifestyle</typeparam>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.AllTypes">
            <summary>
            Describes a set of components to register in the kernel.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.Of(System.Type)">
            <summary>
            Describes all the types based on <c>basedOn</c>.
            </summary>
            <param name="basedOn">The base type.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.Of``1">
            <summary>
            Describes all the types based on type T.
            </summary>
            <typeparam name="T">The base type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.Pick">
            <summary>
            Describes any types that are supplied.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyNamed(System.String)">
            <summary>
            Prepares to register types from an assembly.
            </summary>
            <param name="assemblyName">The assembly name.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssembly(System.Reflection.Assembly)">
            <summary>
            Prepares to register types from an assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyContaining(System.Type)">
            <summary>
            Prepares to register types from an assembly containing the type.
            </summary>
            <param name="type">The type belonging to the assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyContaining``1">
            <summary>
            Prepares to register types from an assembly containing the type.
            </summary>
            <typeparam name="T">The type belonging to the assembly.</typeparam>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.From(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.Pick(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypes.From(System.Type[])">
            <summary>
            Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.AllTypesOf">
            <summary>
            Describes a related group of components to register in the kernel.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.FromAssemblyNamed(System.String)">
            <summary>
            Prepares to register types from an assembly.
            </summary>
            <param name="assemblyName">The assembly name.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.FromAssembly(System.Reflection.Assembly)">
            <summary>
            Prepares to register types from an assembly.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.From(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.Pick(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AllTypesOf.From(System.Type[])">
            <summary>
            Prepares to register types from a list of types.
            </summary>
            <param name="types">The list of types.</param>
            <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ConfigureDelegate">
            <summary>
            Delegate for custom registration configuration.
            </summary>
            <param name="registration">The component registration.</param>
            <returns>Not uaed.</returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.BasedOnDescriptor">
            <summary>
            Describes how to register a group of related types.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.IRegistration">
            <summary>
            The contract for all registrations with the kernel.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.IRegistration.Register(Castle.MicroKernel.IKernel)">
            <summary>
            Performs the registration in the <see cref="T:Castle.MicroKernel.IKernel"/>.
            </summary>
            <param name="kernel">The kernel.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.#ctor(System.Type,Castle.MicroKernel.Registration.FromDescriptor)">
            <summary>
            Initializes a new instance of the BasedOnDescriptor.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.If(System.Predicate{System.Type})">
            <summary>
            Assigns a conditional predication which must be satisfied.
            </summary>
            <param name="ifFilter">The predicate to satisfy.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Unless(System.Predicate{System.Type})">
            <summary>
            Assigns a conditional predication which must not be satisfied. 
            </summary>
            <param name="unlessFilter">The predicate not to satisify.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Configure(System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
            Allows customized configurations of each matching type.
            </summary>
            <param name="configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Configure(Castle.MicroKernel.Registration.ConfigureDelegate)">
            <summary>
            Allows customized configurations of each matching type.
            </summary>
            <param name="configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.ConfigureFor``1(System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
            Allows customized configurations of each matching type that is 
            assignable to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type assignable from.</typeparam>
            <param name="configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.ConfigureFor``1(Castle.MicroKernel.Registration.ConfigureDelegate)">
            <summary>
            Allows customized configurations of each matching type that is 
            assignable to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type assignable from.</typeparam>
            <param name="configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.AllowMultipleMatches">
            <summary>
            Allows a type to be registered multiple times.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.BasedOn``1">
            <summary>
            Returns the descriptor for accepting a new type.
            </summary>
            <typeparam name="T">The base type.</typeparam>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.BasedOn(System.Type)">
            <summary>
            Returns the descriptor for accepting a new type.
            </summary>
            <param name="basedOn">The base type.</param>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Where(System.Predicate{System.Type})">
            <summary>
            Returns the descriptor for accepting a type based on a condition.
            </summary>
            <param name="accepted">The accepting condition.</param>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.BasedOnDescriptor.InternalBasedOn">
            <summary>
            Gets the type all types must be based on.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Registration.BasedOnDescriptor.WithService">
            <summary>
            Gets the service descriptor.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ConfigureDescriptor">
            <summary>
            Describes a configuration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.#ctor(Castle.MicroKernel.Registration.BasedOnDescriptor,System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
             Initializes a new instance of the ConfigureDescriptor.
            </summary>
            <param name="basedOn">The <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></param>
            <param name="configurer">The configuration action.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.#ctor(Castle.MicroKernel.Registration.BasedOnDescriptor,System.Type,System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
             Initializes a new instance of the ConfigureDescriptor.
            </summary>
            <param name="basedOn">The <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor"/></param>
            <param name="baseType">The base type to match.</param>
            <param name="configurer">The configuration action.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.Configure(System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
            Allows customized configurations of each matching type.
            </summary>
            <param name="configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.Configure(Castle.MicroKernel.Registration.ConfigureDelegate)">
            <summary>
            Allows customized configurations of each matching type.
            </summary>
            <param name="configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.ConfigureFor``1(System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
            <summary>
            Allows customized configurations of each matching type that is 
            assignable to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type assignable from.</typeparam>
            <param name="configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.ConfigureFor``1(Castle.MicroKernel.Registration.ConfigureDelegate)">
            <summary>
            Allows customized configurations of each matching type that is 
            assignable to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type assignable from.</typeparam>
            <param name="configurer">The configuration action.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ConfigureDescriptor.Apply(Castle.MicroKernel.Registration.ComponentRegistration)">
            <summary>
            Performs the component configuration.
            </summary>
            <param name="registration">The component registration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.FromAssemblyDescriptor">
            <summary>
            Selects a set of types from an assembly.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.FromDescriptor">
            <summary>
            Describes the source of types to register.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.AllowMultipleMatches">
            <summary>
            Allows a type to be registered multiple times.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.BasedOn``1">
            <summary>
            Returns the descriptor for accepting a type.
            </summary>
            <typeparam name="T">The base type.</typeparam>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.BasedOn(System.Type)">
            <summary>
            Returns the descriptor for accepting a type.
            </summary>
            <param name="basedOn">The base type.</param>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.FromDescriptor.Where(System.Predicate{System.Type})">
            <summary>
            Returns the descriptor for accepting a type based on a condition.
            </summary>
            <param name="accepted">The accepting condition.</param>
            <returns>The descriptor for the type.</returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.FromTypesDescriptor">
            <summary>
            Selects an existing set of types to register.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ServiceDescriptor">
            <summary>
            Describes how to select a types service.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Base">
            <summary>
            Uses the base type matched on.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.FirstInterface">
            <summary>
            Uses the first interface of a type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.FromInterface(System.Type)">
            <summary>
            Uses <paramref name="implements"/> to lookup the sub interface.
            For example: if you have IService and 
            IProductService : ISomeInterface, IService, ISomeOtherInterface.
            When you call FromInterface(typeof(IService)) then IProductService
            will be used. Useful when you want to register _all_ your services
            and but not want to specify all of them.
            </summary>
            <param name="implements"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.FromInterface">
            <summary>
            Uses base type to lookup the sub interface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Select(Castle.MicroKernel.Registration.ServiceDescriptor.ServiceSelector)">
            <summary>
            Assigns a custom service selection strategy.
            </summary>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Select(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Assigns the supplied service types.
            </summary>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.WorkaroundCLRBug(System.Type)">
            <summary>
            This is a workaround for a CLR bug in
            which GetInterfaces() returns interfaces
            with no implementations.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AttributeDescriptor`1.#ctor(System.String,System.String)">
            <summary>
            Constructs the <see cref="T:Castle.MicroKernel.Registration.AttributeDescriptor`1"/> descriptor with name and value.
            </summary>
            <param name="name">The attribute name.</param>
            <param name="value">The attribute value.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AttributeKeyDescriptor`1.#ctor(Castle.MicroKernel.Registration.ComponentRegistration{`0},System.String)">
            <summary>
            Constructs the <see cref="T:Castle.MicroKernel.Registration.AttributeKeyDescriptor`1"/> descriptor with name.
            </summary>
            <param name="component">The component.</param>
            <param name="name">The attribute name.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.AttributeKeyDescriptor`1.Eq(System.Object)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.AttributeKeyDescriptor`1"/> with value.
            </summary>
            <param name="value">The attribute value.</param>
            <returns>The <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Component">
            <summary>
            Factory for creating <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration"/> objects.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For(System.Type)">
            <summary>
            Creates a component registration for the <paramref name="serviceType"/>
            </summary>
            <param name="serviceType">Type of the service.</param>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For(System.Type[])">
            <summary>
            Creates a component registration for the <paramref name="serviceTypes"/>
            </summary>
            <param name="serviceTypes">Types of the service.</param>
            <returns>The component registration.</returns>B
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Creates a component registration for the <paramref name="serviceTypes"/>
            </summary>
            <param name="serviceTypes">Types of the service.</param>
            <returns>The component registration.</returns>B
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``1">
            <summary>
            Creates a component registration for the service type.
            </summary>
            <typeparam name="S">The service type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``2">
            <summary>
            Creates a component registration for the service types.
            </summary>
            <typeparam name="S">The primary service type.</typeparam>
            <typeparam name="F">The forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``3">
            <summary>
            Creates a component registration for the service types.
            </summary>
            <typeparam name="S">The primary service type.</typeparam>
            <typeparam name="F1">The first forwarded type.</typeparam>
            <typeparam name="F2">The second forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``4">
            <summary>
            Creates a component registration for the service types.
            </summary>
            <typeparam name="S">The primary service type.</typeparam>
            <typeparam name="F1">The first forwarded type.</typeparam>
            <typeparam name="F2">The second forwarded type.</typeparam>
            <typeparam name="F3">The third forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For``5">
            <summary>
            Creates a component registration for the service types.
            </summary>
            <typeparam name="S">The primary service type.</typeparam>
            <typeparam name="F1">The first forwarded type.</typeparam>
            <typeparam name="F2">The second forwarded type.</typeparam>
            <typeparam name="F3">The third forwarded type.</typeparam>
            <typeparam name="F4">The fourth forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.For(Castle.Core.ComponentModel)">
            <summary>
            Create a component registration for an exisiting <see cref="T:Castle.Core.ComponentModel"/>
            </summary>
            <param name="model">The component model.</param>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.ServiceAlreadyRegistered(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Determines if the component service is already registered.
            </summary>
            <param name="kernel">The kernel.</param>
            <param name="model">The component model.</param>
            <returns>true if the service is already registered.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInNamespace(System.String)">
            <summary>
            Creates a predicate to check if a component is in a namespace.
            </summary>
            <param name="namespace">The namespace.</param>
            <returns>true if the component type is in the namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs(System.Type)">
            <summary>
            Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <param name="type">The component type to test namespace against.</param>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs``1">
            <summary>
            Creates a predicate to check if a component shares a namespace with another.
            </summary>
            <typeparam name="T">The component type to test namespace against.</typeparam>
            <returns>true if the component is in the same namespace.</returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ComponentFilter">
            <summary>
            Delegate to filter component registration.
            </summary>
            <param name="kernel">The kernel.</param>
            <param name="model">The component model.</param>
            <returns>true if accepted.</returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ComponentRegistration`1">
            <summary>
            Registration for a single type as a component with the kernel.
            <para/>
            You can create a new registration with the <see cref="T:Castle.MicroKernel.Registration.Component"/> factory.
            </summary>
            <typeparam name="S">The service type</typeparam>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.#ctor(Castle.Core.ComponentModel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/> class
            with an existing <see cref="T:Castle.Core.ComponentModel"/>.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OverWrite">
            <summary>
            With the overwrite.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Named(System.String)">
            <summary>
            Change the name of this registration. 
            This will be the key for the component in the kernel.
            <para/>
            If not set, the <see cref="P:System.Type.FullName"/> of the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation"/>
            will be used as the key to register the component.
            </summary>
            <param name="name">The name of this registration.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy``1">
            <summary>
            Sets the concrete type that implements the service to <typeparamref name="C"/>.
            <para/>
            If not set, the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceType"/> will be used as the implementation for this component.
            </summary>
            <typeparam name="C">The type that is the implementation for the service.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy(System.Type)">
            <summary>
            Sets the concrete type that implements the service to <paramref name="type"/>.
            <para/>
            If not set, the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceType"/> will be used as the implementation for this component.
            </summary>
            <param name="type">The type that is the implementation for the service.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Instance(`0)">
            <summary>
            Assigns an existing instance as the component for this registration.
            </summary>
            <param name="instance">The component instance.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward(System.Type[])">
            <summary>
            Registers the service types on behalf of this component.
            </summary>
            <param name="types">The types to forward.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``1">
            <summary>
            Registers the service types on behalf of this component.
            </summary>
            <typeparam name="F">The forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``2">
            <summary>
            Registers the service types on behalf of this component.
            </summary>
            <typeparam name="F1">The first forwarded type.</typeparam>
            <typeparam name="F2">The second forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``3">
            <summary>
            Registers the service types on behalf of this component.
            </summary>
            <typeparam name="F1">The first forwarded type.</typeparam>
            <typeparam name="F2">The second forwarded type.</typeparam>
            <typeparam name="F3">The third forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``4">
            <summary>
            Registers the service types on behalf of this component.
            </summary>
            <typeparam name="F1">The first forwarded type.</typeparam>
            <typeparam name="F2">The second forwarded type.</typeparam>
            <typeparam name="F3">The third forwarded type.</typeparam>
            <typeparam name="F4">The fourth forwarded type.</typeparam>
            <returns>The component registration.</returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Registers the service types on behalf of this component.
            </summary>
            <param name="types">The types to forward.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Activator``1">
            <summary>
            Set a custom <see cref="T:Castle.MicroKernel.IComponentActivator"/> which creates and destroys the component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ExtendedProperties(Castle.MicroKernel.Registration.Property[])">
            <summary>
            Sets <see cref="P:Castle.Core.ComponentModel.ExtendedProperties"/> for this component.
            </summary>
            <param name="properties">The extended properties.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ExtendedProperties(System.Object)">
            <summary>
            Sets <see cref="P:Castle.Core.ComponentModel.ExtendedProperties"/> for this component.
            </summary>
            <param name="anonymous">The extendend properties as key/value pairs.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.Property[])">
            <summary>
            Specify custom dependencies using <see cref="M:Castle.MicroKernel.Registration.Property.ForKey(System.String)"/>.
            <para/>
            Use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(Castle.MicroKernel.Registration.ServiceOverride[])"/> to specify the components
            this component should be resolved with.
            </summary>
            <param name="dependencies">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Collections.IDictionary)">
            <summary>
            Uses a dictionary of key/value pairs, to specify custom dependencies.
            <para/>
            Use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(System.Collections.IDictionary)"/> to specify the components
            this component should be resolved with.
            </summary>
            <param name="dependencies">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Object)">
            <summary>
            Uses an (anonymous) object as a dictionary, to specify custom dependencies.
            <para/>
            Use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(System.Object)"/> to specify the components
            this component should be resolved with.
            </summary>
            <param name="anonymous">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.CustomDependencies(Castle.MicroKernel.Registration.Property[])">
            <summary>
            Obsolete, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.Property[])"/> instead.
            </summary>
            <param name="dependencies">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.CustomDependencies(System.Collections.IDictionary)">
            <summary>
            Obsolete, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Collections.IDictionary)"/> instead.
            </summary>
            <param name="dependencies">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.CustomDependencies(System.Object)">
            <summary>
            Obsolete, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Object)"/> instead.
            </summary>
            <param name="dependencies">The dependencies.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(Castle.MicroKernel.Registration.ServiceOverride[])">
            <summary>
            Override (some of) the services that this component needs.
            Use <see cref="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey(System.String)"/> to create an override.
            <para/>
            Each key represents the service dependency of this component, for example the name of a constructor argument or a property.
            The corresponding value is the key of an other component registered to the kernel, and is used to resolve the dependency.
            <para/>
            To specify dependencies which are not services, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.Property[])"/>
            </summary>
            <param name="overrides">The service overrides.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(System.Collections.IDictionary)">
            <summary>
            Override (some of) the services that this component needs, using a dictionary.
            <para/>
            Each key represents the service dependency of this component, for example the name of a constructor argument or a property.
            The corresponding value is the key of an other component registered to the kernel, and is used to resolve the dependency.
            <para/>
            To specify dependencies which are not services, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Collections.IDictionary)"/>
            </summary>
            <param name="overrides">The service overrides.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(System.Object)">
            <summary>
            Override (some of) the services that this component needs, using an (anonymous) object as a dictionary.
            <para/>
            Each key represents the service dependency of this component, for example the name of a constructor argument or a property.
            The corresponding value is the key of an other component registered to the kernel, and is used to resolve the dependency.
            <para/>
            To specify dependencies which are not services, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Object)"/>
            </summary>
            <param name="anonymous">The service overrides.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Parameters(Castle.MicroKernel.Registration.Parameter[])">
            <summary>
            Set configuration parameters with string or <see cref="T:Castle.Core.Configuration.IConfiguration"/> values.
            </summary>
            <param name="parameters">The parameters.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Attribute(System.String)">
            <summary>
            Creates an attribute descriptor.
            </summary>
            <param name="key">The attribute key.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Configuration(Castle.MicroKernel.Registration.Node[])">
            <summary>
            Apply more complex configuration to this component registration.
            </summary>
            <param name="configNodes">The config nodes.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Configuration(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Apply more complex configuration to this component registration.
            </summary>
            <param name="configuration">The configuration <see cref="T:Castle.Core.Configuration.MutableConfiguration"/>.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors(Castle.Core.InterceptorReference[])">
            <summary>
            Set the interceptors for this component.
            </summary>
            <param name="interceptors">The interceptors.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors(System.Type[])">
            <summary>
            Set the interceptors for this component.
            </summary>
            <param name="interceptors">The interceptors.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors``1">
            <summary>
            Set the interceptor for this component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors``2">
            <summary>
            Set the interceptor for this component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors(System.String[])">
            <summary>
            Set the interceptor for this component.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.SelectInterceptorsWith(Castle.Core.Interceptor.IInterceptorSelector)">
            <summary>
            Sets the interceptor selector for this component.
            </summary>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Startable">
            <summary>
            Marks the component as startable.
            </summary>
            <returns></returns>
            <remarks>Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility"/> 
            to the kernel, before registering this component.</remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.StartUsingMethod(System.String)">
            <summary>
            Assigns the start method for the startable.
            </summary>
            <param name="startMethod">The start method.</param>
            <returns></returns>
            <remarks>Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility"/> 
            to the kernel, before registering this component.</remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.StopUsingMethod(System.String)">
            <summary>
            Assigns the stop method for the startable.
            </summary>
            <param name="stopMethod">The stop method.</param>
            <returns></returns>
            <remarks>Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility"/> 
            to the kernel, before registering this component.</remarks>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OnCreate(Castle.MicroKernel.LifecycleConcerns.OnCreateActionDelegate{`0}[])">
            <summary>
            Stores a set of <see cref="T:Castle.MicroKernel.LifecycleConcerns.OnCreateActionDelegate`1"/> which will be invoked when the component
            is created and before it's returned from the container.
            </summary>
            <param name="actions">A set of actions to be executed right after the component is created and before it's returned from the container.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersDelegate)">
            <summary>
            Allows custom dependencies to by defined dyncamically.
            </summary>
            <param name="resolve">The delegate used for providing dynamic parameters.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersResolveDelegate)">
            <summary>
            Allows custom dependencies to by defined dyncamically with releasing capability.
            </summary>
            <param name="resolve">The delegate used for providing dynamic parameters.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ActAs(System.Object[])">
            <summary>
            Marks the components with one or more actors.
            </summary>
            <param name="actors">The component actors.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.If(Castle.MicroKernel.Registration.ComponentFilter)">
            <summary>
            Assigns a conditional predication which must be satisfied.
            <para />
            The component will only be registered into the kernel 
            if this predicate is satisfied (or not assigned at all).
            </summary>
            <param name="ifFilter">The predicate to satisfy.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Unless(Castle.MicroKernel.Registration.ComponentFilter)">
            <summary>
            Assigns a conditional predication which must not be satisfied. 
            <para />
            The component will only be registered into the kernel 
            if this predicate is not satisfied (or not assigned at all).
            </summary>
            <param name="unlessFilter">The predicate not to satisify.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Castle#MicroKernel#Registration#IRegistration#Register(Castle.MicroKernel.IKernel)">
            <summary>
            Registers this component with the <see cref="T:Castle.MicroKernel.IKernel"/>.
            </summary>
            <param name="kernel">The kernel.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.AddAttributeDescriptor(System.String,System.String)">
            <summary>
            Adds the attribute descriptor.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.AddDescriptor(Castle.MicroKernel.Registration.ComponentDescriptor{`0})">
            <summary>
            Adds the descriptor.
            </summary>
            <param name="descriptor">The descriptor.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(Castle.MicroKernel.Registration.Function{``0})">
            <summary>
            Uses a factory method to instantiate the component.
            Requires the <see cref="T:Castle.Facilities.FactorySupport.FactorySupportFacility"/> to be installed.
            </summary>
            <typeparam name="T">Implementation type</typeparam>
            <param name="factoryMethod">Factory method</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Converter{Castle.MicroKernel.IKernel,``0})">
            <summary>
            Uses a factory method to instantiate the component.
            Requires the <see cref="T:Castle.Facilities.FactorySupport.FactorySupportFacility"/> to be installed.
            </summary>
            <typeparam name="T">Implementation type</typeparam>
            <param name="factoryMethod">Factory method</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Func{Castle.MicroKernel.IKernel,Castle.MicroKernel.CreationContext,``0})">
            <summary>
            Uses a factory method to instantiate the component.
            Requires the <see cref="T:Castle.Facilities.FactorySupport.FactorySupportFacility"/> to be installed.
            </summary>
            <typeparam name="T">Implementation type</typeparam>
            <param name="factoryMethod">Factory method</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactory``2(System.Converter{``0,``1})">
            <summary>
            Uses a factory to instantiate the component
            </summary>
            <typeparam name="U">Factory type. This factory has to be registered in the kernel.</typeparam>
            <typeparam name="V">Implementation type.</typeparam>
            <param name="factory">Factory invocation</param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Name">
            <summary>
            The name of the component. Will become the key for the component in the kernel.
            <para/>
            To set the name, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Named(System.String)"/>.
            <para/>
            If not set, the <see cref="P:System.Type.FullName"/> of the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation"/>
            will be used as the key to register the component.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceType">
            <summary>
            The type of the service, the same as <typeparamref name="S"/>.
            <para/>
            This is the first type passed to <see cref="M:Castle.MicroKernel.Registration.Component.For(System.Type)"/>.
            </summary>
            <value>The type of the service.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.ForwardedTypes">
            <summary>
            Gets the forwarded service types on behalf of this component.
            <para/>
            Add more types to forward using <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward(System.Type[])"/>.
            </summary>
            <value>The types of the forwarded services.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation">
            <summary>
            The concrete type that implements the service.
            <para/>
            To set the implementation, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy(System.Type)"/>.
            </summary>
            <value>The implementation of the service.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Proxy">
            <summary>
            Set proxy for this component.
            </summary>
            <value>The proxy.</value>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.LifeStyle">
            <summary>
            Set the lifestyle of this component.
            For example singleton and transient (also known as 'factory').
            </summary>
            <value>The with lifestyle.</value>
        </member>
        <member name="T:Castle.MicroKernel.Registration.KernelToT`1">
            <summary>
            Helper wrapper around Converter
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Castle.MicroKernel.Registration.GenericFactory`1">
            <summary>
            Helper factory class
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Castle.MicroKernel.Registration.GenericFactoryWithContext`1">
            <summary>
            Helper factory class
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Castle.MicroKernel.Registration.GenericFactoryWithKernel`1">
            <summary>
            Helper factory class
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ComponentRegistration">
            <summary>
            A non-generic <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/>.
            <para/>
            You can create a new registration with the <see cref="T:Castle.MicroKernel.Registration.Component"/> factory.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Node">
            <summary>
            Represents a configuration child.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Node.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Applies the configuration node.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Attrib">
            <summary>
            Represents a configuration attribute.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Attrib.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Applies the configuration node.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Attrib.ForName(System.String)">
            <summary>
            Create a <see cref="T:Castle.MicroKernel.Registration.NamedAttribute"/> with name.
            </summary>
            <param name="name">The attribute name.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.NamedAttribute"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.NamedAttribute">
            <summary>
            Represents a named attribute.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedAttribute.Eq(System.String)">
            <summary>
            Builds the <see cref="T:System.Attribute"/> with name/value.
            </summary>
            <param name="value">The attribute value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedAttribute.Eq(System.Object)">
            <summary>
            Builds the <see cref="T:System.Attribute"/> with name/value.
            </summary>
            <param name="value">The attribute value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Child">
            <summary>
            Represents a configuration child.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Child.ForName(System.String)">
            <summary>
            Create a <see cref="T:Castle.MicroKernel.Registration.NamedChild"/> with name.
            </summary>
            <param name="name">The child name.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.NamedChild"/></returns>
        </member>
        <member name="T:Castle.MicroKernel.Registration.NamedChild">
            <summary>
            Represents a named child.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(System.String)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/> with name/value.
            </summary>
            <param name="value">The child value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(System.Object)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/> with name/value.
            </summary>
            <param name="value">The child value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.ComplexChild"/> with name/config.
            </summary>
            <param name="configNode">The child configuration.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ComplexChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(Castle.MicroKernel.Registration.Node[])">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.Child"/> with name/config.
            </summary>
            <param name="childNodes">The child nodes.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.CompoundChild"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.NamedChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Applies the configuration node.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.SimpleChild">
            <summary>
            Represents a simple child node.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.SimpleChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Applies the configuration node.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ComplexChild">
            <summary>
            Represents a complex child node.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ComplexChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Applies the configuration node.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.CompoundChild">
            <summary>
            Represents a compound child node.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.CompoundChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Applies the configuration node.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="T:Castle.MicroKernel.Registration.OnCreateComponentDescriptor`1">
            <summary>
            Adds the actions to ExtendedProperties.
            </summary>
            <typeparam name="S"></typeparam>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Parameter">
            <summary>
            Represents a configuration parameter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Parameter.ForKey(System.String)">
            <summary>
            Create a <see cref="T:Castle.MicroKernel.Registration.ParameterKey"/> with key.
            </summary>
            <param name="key">The parameter key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ParameterKey"/></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Parameter.Key">
            <summary>
            Gets the parameter key.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Parameter.Value">
            <summary>
            Gets the parameter value.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Parameter.ConfigNode">
            <summary>
            Gets the parameter configuration.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ParameterKey">
            <summary>
            Represents a parameter key.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ParameterKey.Eq(System.String)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.Parameter"/> with key/value.
            </summary>
            <param name="value">The parameter value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.Parameter"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ParameterKey.Eq(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.Parameter"/> with key/config.
            </summary>
            <param name="configNode">The parameter configuration.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.Parameter"/></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ParameterKey.Name">
            <summary>
            The parameter key name.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.Property">
            <summary>
            Represents a key/value pair.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.Property.ForKey(System.String)">
            <summary>
            Create a <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/> with key.
            </summary>
            <param name="key">The property key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.PropertyKey"/></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Property.Key">
            <summary>
            Gets the property key.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.Registration.Property.Value">
            <summary>
            Gets the property value.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.PropertyKey">
            <summary>
            Represents a property key.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.PropertyKey.Eq(System.Object)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.Property"/> with key/value.
            </summary>
            <param name="value">The property value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.Property"/></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.PropertyKey.Name">
            <summary>
            The property key name.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ServiceOverride">
            <summary>
            Represents a service override.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey(System.String)">
            <summary>
            Creates a <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/> with key.
            </summary>
            <param name="key">The service override key.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey"/></returns>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ServiceOverride.Type">
            <summary>
            Gets the optional value type specifier.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Registration.ServiceOverrideKey">
            <summary>
            Represents a service override key.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq(System.String)">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/value.
            </summary>
            <param name="value">The service overeride value.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq(System.String[])">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/values.
            </summary>
            <param name="value">The service overeride values.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq``1(System.String[])">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/values.
            </summary>
            <param name="value">The service overeride values.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
            <typeparam name="V">The value type.</typeparam>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/values.
            </summary>
            <param name="value">The service overeride values.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
        </member>
        <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/> with key/values.
            </summary>
            <param name="value">The service overeride values.</param>
            <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride"/></returns>
            <typeparam name="V">The value type.</typeparam>
        </member>
        <member name="P:Castle.MicroKernel.Registration.ServiceOverrideKey.Name">
            <summary>
            Gets the service override key name.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IReleasePolicy">
            <summary>
            Summary description for IReleasePolicy.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy">
            <summary>
            Only tracks components that have decommission steps
            registered or have pooled lifestyle.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Releasers.NoTrackingReleasePolicy">
            <summary>
            No tracking of component instances are made.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Releasers.NoTrackingReleasePolicy.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Releasers.NoTrackingReleasePolicy"/> class.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ArrayResolver">
            <summary>
            Handle dependencies of services in the format of typed arrays.
            </summary>
            <remarks>
            This is a complimentary <see cref="T:Castle.MicroKernel.ISubDependencyResolver"/> implementation 
            that is capable of satisfying dependencies of services as typed arrays.
            <para>
            Note that it will take precedence over service override for arrays defined 
            on the configuration.
            </para>
            </remarks>
            <example>
            In order to install the resolver:
            <code>
            var kernel = new DefaultKernel();
            kernel.Resolver.AddSubResolver(new ArrayResolver(kernel));
            </code>
            
            <para>
            To use it, assuming that IService is on the container:
            </para>
            
            <code>
            public class Component
            {
                public Component(IService[] services)
                {
                }
            }
            </code>
            </example>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ListResolver">
            <summary>
            Handle dependencies of services in the format of generic IList.
            </summary>
            <remarks>
            This is a complimentary <see cref="T:Castle.MicroKernel.ISubDependencyResolver"/> implementation 
            that is capable of satisfying dependencies of services generic IList.
            <para>
            Note that it will take precedence over service override for lists defined 
            on the configuration.
            </para>
            </remarks>
            <example>
            In order to install the resolver:
            <code>
            var kernel = new DefaultKernel();
            kernel.Resolver.AddSubResolver(new ListResolver(kernel));
            </code>
            
            <para>
            To use it, assuming that IService is on the container:
            </para>
            
            <code>
            public class Component
            {
                public Component(IList&lt;IService&gt; services)
                {
                }
            }
            </code>
            </example>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.DefaultDependencyResolver">
            <summary>
            Default implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver"/>.
            This implementation is quite simple, but still should be useful
            for 99% of situations. 
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IDependencyResolver">
            <summary>
            Implementors should use a strategy to obtain 
            valid references to properties and/or services 
            requested in the dependency model.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.Initialize(Castle.MicroKernel.DependencyDelegate)">
            <summary>
            This method is called with a delegate for firing the
            IKernelEvents.DependencyResolving event.
            </summary>
            <param name="resolving">The delegate used to fire the event</param>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.AddSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
            Registers a sub resolver instance
            </summary>
            <param name="subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.RemoveSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
            Unregisters a sub resolver instance previously registered
            </summary>
            <param name="subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.#ctor(Castle.MicroKernel.IKernel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DefaultDependencyResolver"/> class.
            </summary>
            <param name="kernel">The kernel.</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Initialize(Castle.MicroKernel.DependencyDelegate)">
            <summary>
            Initializes this instance with the specified dependency delegate.
            </summary>
            <param name="dependencyDelegate">The dependency delegate.</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.AddSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
            Registers a sub resolver instance
            </summary>
            <param name="subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RemoveSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
            <summary>
            Unregisters a sub resolver instance previously registered
            </summary>
            <param name="subResolver">The subresolver instance</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.CanResolve(Castle.MicroKernel.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Returns true if the resolver is able to satisfy the specified dependency.
            </summary>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="contextHandlerResolver">Parent resolver</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns><c>true</c> if the dependency can be satisfied</returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Resolve(Castle.MicroKernel.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Try to resolve the dependency by checking the parameters in 
            the model or checking the Kernel for the requested service.
            </summary>
            <remarks>
            The dependency resolver has the following precedence order:
            <list type="bullet">
            <item><description>
            The dependency is checked within the <see cref="T:Castle.MicroKernel.CreationContext"/>
            </description></item>
            <item><description>
            The dependency is checked within the <see cref="T:Castle.MicroKernel.IHandler"/> instance for the component
            </description></item>
            <item><description>
            The dependency is checked within the registered <see cref="T:Castle.MicroKernel.ISubDependencyResolver"/>s
            </description></item>
            <item><description>
            Finally the resolver tries the normal flow 
            which is using the configuration
            or other component to satisfy the dependency
            </description></item>
            </list>
            </remarks>
            <param name="context">Creation context, which is a resolver itself</param>
            <param name="contextHandlerResolver">Parent resolver</param>
            <param name="model">Model of the component that is requesting the dependency</param>
            <param name="dependency">The dependency model</param>
            <returns>The dependency resolved value or null</returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ExtractComponentKey(System.String,System.String)">
            <summary>
            Extracts the component name from the a ref strings which is
            ${something}
            </summary>
            <param name="name"></param>
            <param name="keyValue"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RebuildContextForParameter(Castle.MicroKernel.CreationContext,System.Type)">
            <summary>
            This method rebuild the context for the parameter type.
            Naive implementation.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.DependencyResolverException">
            <summary>
            Summary description for DependencyResolverException.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.ILazyComponentLoader">
            <summary>
            Provides lazy registration capabilities to the container.
            </summary>
            <remarks>
            When a component is requested from a container and it was not registered, 
            container loads up all registered implementers of this interface and asks 
            them in turn whethere they can provide that component, until it finds one that will.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.ILazyComponentLoader.Load(System.String,System.Type)">
            <summary>
            Used by container to allow the loader gister component for given <paramref name="key"/> and <paramref name="service"/> to the container at the time when it is requested
            </summary>
            <param name="key">Key of the requested component or null</param>
            <param name="service">Type of requested service or null</param>
            <returns>Registration that registers component for given key and/or service or null.</returns>
            <remarks>
            While either key or service can be null reference it is guaranteed that at least one of them will not be null.
            When implementer opts in to provide the requested component (by returning not-null registration) it is required
            to register component for requested key/service combination (when one of the elements is null, it should be ignored as well).
            When implementer does not want to register the requested component it nust return null.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.IConfigurationStore"/>
            does not try to obtain an external configuration by any means.
            Its only purpose is to serve as a base class for subclasses
            that might obtain the configuration node from anywhere.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ISubSystem">
            <summary>
            A subsystem is used by the MicroKernel to deal 
            with a specific concern.  
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ISubSystem.Init(Castle.MicroKernel.IKernel)">
            <summary>
            Initializes the subsystem
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.ISubSystem.Terminate">
            <summary>
            Should perform the termination
            of the subsystem instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IConfigurationStore">
            <summary>
            The contract used by the kernel to obtain
            external configuration for the components and
            facilities.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a facility key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a component key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.AddBootstrapComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a  configuration node with a bootstrap component key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.AddChildContainerConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Adds the child container configuration.
            </summary>
            <param name="name">The container's name.</param>
            <param name="config">The config.</param>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetChildContainerConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified child container key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetFacilityConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified facility key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetBootstrapComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetFacilities">
            <summary>
            Returns all configuration nodes for facilities
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetComponents">
            <summary>
            Returns all configuration nodes for components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetBootstrapComponents">
            <summary>
            Returns all configuration nodes for bootstrap components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetConfigurationForChildContainers">
            <summary>
            Gets the child containers configuration nodes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetResource(System.String,Castle.Core.Resource.IResource)">
            <summary>
            
            </summary>
            <param name="resourceUri"></param>
            <param name="resource"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a facility key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a component key
            </summary>
            <param name="key">item key</param>
            <param name="config">Configuration node</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddBootstrapComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a bootstrap component key
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddChildContainerConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Adds the child container configuration.
            </summary>
            <param name="key">The key.</param>
            <param name="config">The config.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetFacilityConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with
            the specified facility key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetChildContainerConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with
            the specified child container key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key">item key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetBootstrapComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetFacilities">
            <summary>
            Returns all configuration nodes for facilities
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetBootstrapComponents">
            <summary>
            Returns all configuration nodes for bootstrap components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetConfigurationForChildContainers">
            <summary>
            Returns all configuration nodes for child containers
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetComponents">
            <summary>
            Returns all configuration nodes for components
            </summary>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter">
            <summary>
            Base implementation of <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter">
            <summary>
            Implements a conversion logic to a type of a
            set of types. 
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type)">
            <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type with the specified 
            configuration
            </summary>
            <param name="type"></param>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(System.String,System.Type)">
            <summary>
            Should perform the conversion from the
            string representation specified to the type
            specified.
            </summary>
            <param name="value"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(Castle.Core.Configuration.IConfiguration,System.Type)">
            <summary>
            Should perform the conversion from the
            configuration node specified to the type
            specified.
            </summary>
            <param name="configuration"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter.CanHandleType(System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type with the specified
            configuration
            </summary>
            <param name="type"></param>
            <param name="configuration"></param>
            <returns></returns>
            <remarks>
            The default behavior is to just pass it to the normal CanHadnleType
            peeking into the configuration is used for some advanced functionality
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.GenericDictionaryConverter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.GenericDictionaryConverter"/> class.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IGenericCollectionConverterHelper">
            <summary>
            This interface is needed because we want to isolate ourself from
            the generic parameters, so we can work type safe inside the implementations,
            and still call from non generic types outside.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.GenericListConverter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.GenericListConverter"/> class.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.AttributeAwareConverter">
            <summary>
            Looks for a <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute"/> on the type to be converted. 
            If found, the TypeConverter defined by the attribute is used to perform the conversion.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IKernelDependentConverter">
            <summary>
            Marker interface that signals that a converter
            depends on IKernel to be able to perform 
            the conversion.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ComponentModelConverter">
            <summary>
            Attempts to utilize an existing <see cref="T:System.ComponentModel.TypeConverter"/> for conversion
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.CreateInstance(System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Creates the target type instance.
            </summary>
            <param name="type">The type.</param>
            <param name="configuration">The configuration.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ChooseConstructor(System.Type)">
            <summary>
            Chooses the first non default constructor. Throws an exception if more than 
            one non default constructor is found
            </summary>
            <param name="type"></param>
            <returns>The chosen constructor, or <c>null</c> if none was found</returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConvertConstructorParameters(System.Reflection.ConstructorInfo,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Converts the constructor parameters.
            </summary>
            <param name="constructor">The constructor.</param>
            <param name="configuration">The configuration.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConvertPropertyValues(System.Object,System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Converts the property values.
            </summary>
            <param name="instance">The instance.</param>
            <param name="type">The type.</param>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.FindChildIgnoreCase(Castle.Core.Configuration.IConfiguration,System.String)">
            <summary>
            Finds the child (case insensitive).
            </summary>
            <param name="config">The config.</param>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConversionManager">
            <summary>
            Gets the conversion manager.
            </summary>
            <value>The conversion manager.</value>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.EnumConverter">
            <summary>
            Converts a string representation to an enum value
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.PrimitiveConverter">
            <summary>
            Implements all standard conversions.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.TypeNameConverter">
            <summary>
            Convert a type name to a Type instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException">
            <summary>
            Summary description for ConverterException.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute">
            <summary>
            Declares a type as being convertible by a <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter"/> and optionally defines the converter to be used
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute.#ctor">
            <summary>
            Defines the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter"/> to be used to convert the type
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute.#ctor(System.Type)">
            <summary>
            Defines the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter"/> to be used to convert the type
            </summary>
            <param name="converterType"></param>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.DefaultConversionManager">
            <summary>
            Composition of all available conversion managers
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IConversionManager">
            <summary>
            Establish a composition interface and a subsystem.
            Implementors should delegate the conversion to 
            a instance of a type converter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.IConversionManager.Add(Castle.MicroKernel.SubSystems.Conversion.ITypeConverter)">
            <summary>
            Register a type converter instance.
            </summary>
            <param name="converter"></param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.BinaryTreeComponentName.FindSuccessor(Castle.MicroKernel.SubSystems.Naming.TreeNode)">
            <summary>
            Method finds the next biggest node
            It assumes Add puts lesser nodes on the right
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.left">
            <summary>Node's left</summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.right">
            <summary>Node's right</summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.parent">
            <summary>Node's parent</summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.nextSibling">
            <summary>DA Linked List</summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.String)">
            <summary>
            Creates a ComponentName using a name pattern like
            "service:key=value,key2=value2"
            </summary>
            <param name="name">Complete name</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.String,System.String)">
            <summary>
            Creates a ComponentName with specified service and 
            properties.
            </summary>
            <param name="service">Service name</param>
            <param name="properties">Property list.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.Setup(System.String)">
            <summary>
            Parses the full name extracting the service and properties.
            </summary>
            <param name="name">Full name.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupService(System.String)">
            <summary>
            Sets up the service. Can be empty but can't be null.
            </summary>
            <param name="service"></param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupProperties(System.String)">
            <summary>
            Parses and validate a properties list string like 
            "key=value,key2=value2" and so on.
            </summary>
            <param name="properties">Property list.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupProperties(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Validates a properties IDictionary.
            </summary>
            <param name="properties">Property list.</param>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem">
            <summary>
            Default <see cref="T:Castle.MicroKernel.INamingSubSystem"/> implementation.
            Keeps services map as a simple hash table.
            Keeps key map as a list dictionary to maintain order.
            Does not support a query string.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.INamingSubSystem">
            <summary>
            Contract for SubSystem that wishes to keep and coordinate
            component registration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.Register(System.String,Castle.MicroKernel.IHandler)">
            <summary>
            Implementors should register the key and service pointing 
            to the specified handler
            </summary>
            <param name="key"></param>
            <param name="handler"></param>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.UnRegister(System.String)">
            <summary>
            Unregister the handler by the given key
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.UnRegister(System.Type)">
            <summary>
            Unregister the handler by the given service
            </summary>
            <param name="service"></param>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.Contains(System.String)">
            <summary>
            Returns true if there is a component registered 
            for the specified key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.Contains(System.Type)">
            <summary>
            Returns true if there is a component registered 
            for the specified service
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandler(System.String)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandlers(System.String)">
            <summary>
            Returns an array of <see cref="T:Castle.MicroKernel.IHandler"/> that
            satisfies the specified query.
            </summary>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandler(System.Type)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified service.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandler(System.String,System.Type)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified key with the service type.
            <remarks>
            It is expected that this will be used mainly to resolve a generic service
            by its key.
            </remarks>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandlers(System.Type)">
            <summary>
            Returns an array of <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandlers">
            <summary>
            Returns all <see cref="T:Castle.MicroKernel.IHandler"/> registered.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetAssignableHandlers(System.Type)">
            <summary>
            Return <see cref="T:Castle.MicroKernel.IHandler"/>s where components are compatible
            with the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetKey2Handler">
            <summary>
            List of handler by key
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetService2Handler">
            <summary>
            List of handler by service
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.AddHandlerSelector(Castle.MicroKernel.IHandlerSelector)">
            <summary>
            Register a new component resolver that can take part in the decision
            making about which handler to resolve
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.INamingSubSystem.ComponentCount">
            <summary>
            Returns the number of components registered.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.INamingSubSystem.Item(System.Type)">
            <summary>
            Associates a <see cref="T:Castle.MicroKernel.IHandler"/> with 
            the specified service
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.INamingSubSystem.Item(System.String)">
            <summary>
            Associates a <see cref="T:Castle.MicroKernel.IHandler"/> with
            the specified key
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.key2Handler">
            <summary>
            Map(String, IHandler) to map component keys
            to <see cref="T:Castle.MicroKernel.IHandler"/>
            Items in this dictionary are sorted in insertion order.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.service2Handler">
            <summary>
            Map(Type, IHandler) to map a service
            to <see cref="T:Castle.MicroKernel.IHandler"/>.
            If there is more than a single service of the type, only the first
            registered services is stored in this dictionary.
            It serve as a fast lookup for the common case of having a single handler for 
            a type.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem"/> class.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IHandlerSelector">
            <summary>
            Implementors of this interface allow to extend the way the container perform
            component resolution based on some application specific business logic.
            </summary>
            <remarks>
            This is the sibling interface to <seealso cref="T:Castle.MicroKernel.ISubDependencyResolver"/>.
            This is dealing strictly with root components, while the <seealso cref="T:Castle.MicroKernel.ISubDependencyResolver"/> is dealing with
            dependent components.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IHandlerSelector.HasOpinionAbout(System.String,System.Type)">
            <summary>
            Whatever the selector has an opinion about resolving a component with the 
            specified service and key.
            </summary>
            <param name="key">The service key - can be null</param>
            <param name="service">The service interface that we want to resolve</param>
        </member>
        <member name="M:Castle.MicroKernel.IHandlerSelector.SelectHandler(System.String,System.Type,Castle.MicroKernel.IHandler[])">
            <summary>
            Select the appropriate handler from the list of defined handlers.
            The returned handler should be a member from the <paramref name="handlers"/> array.
            </summary>
            <param name="key">The service key - can be null</param>
            <param name="service">The service interface that we want to resolve</param>
            <param name="handlers">The defined handlers</param>
            <returns>The selected handler, or null</returns>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem">
            <summary>
            When requesting a component by service, KeySearchNamingSubSystem first 
            determines if more than one component has been registered for that service.  
            If not, Default resolution occurs.  If so, all of the registered keys for 
            that service are processed through the provided Predicate to determine which 
            key to use for service resolution.  If no Predicate matches, the default 
            resolution occurs.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem"/> class.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.#ctor(System.Predicate{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem"/> class.
            </summary>
            <param name="keyPredicate">The key predicate.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.Register(System.String,Castle.MicroKernel.IHandler)">
            <summary>
            Registers the given handler with the give key.
            </summary>
            <param name="key">The key.</param>
            <param name="handler">The handler.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.UnRegister(System.String)">
            <summary>
            Unregisters the handler associated with the given key
            </summary>
            <param name="key">The key.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.UnRegister(System.Type)">
            <summary>
            Unregisters the handler associated with the given service
            </summary>
            <param name="service">The service.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.KeySearchNamingSubSystem.GetHandler(System.Type)">
            <summary>
            Executes the Predicate against all keys for the registered service to 
            determine which component to return.
            </summary>
            <param name="service">The service.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Naming.NamingPartsSubSystem">
            <summary>
            Alternative <see cref="T:Castle.MicroKernel.INamingSubSystem"/> implementation.
            Extends the default implementation replacing the 
            key support with a more complete ComponentName. Supports
            queries.
            </summary>
            <example>
            The user must register components using the following construction
            <code>
              service:properties
            </code>
            Where properties is a list of key value pairs (comma separated). Example:
            <code>
              protocol:secure=true,version=1.2
            </code>
            The user can then query for components using the same construction:
            <code>
              protocol:secure=true
            </code>
            Or to return all:
            <code>
              protocol:*
            </code>
            </example>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Resource.DefaultResourceSubSystem">
            <summary>
            Pendent
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem">
            <summary>
            An implementation of <c>a</c> should 
            be able to return instances of <see cref="T:Castle.Core.Resource.IResource"/>
            for a given resource identifier.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystemConstants">
            <summary>
            Holds the keys used by Kernel to register/request 
            a subsystem.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ConfigurationStoreKey">
            <summary>
            Key used for the configuration store subsystem
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ConversionManagerKey">
            <summary>
            Key used for the conversion manager
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.NamingKey">
            <summary>
            Key used for the naming subsystem
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ResourceKey">
            <summary>
            Key used for the resource subsystem
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Util.ReferenceComparer">
            <summary>
            Compares if the reference of two objects are equals.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Util.ReferenceExpressionUtil">
            <summary>
            Summary description for ReferenceExpressionUtil.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.DefaultKernel">
            <summary>
            Default implementation of <see cref="T:Castle.MicroKernel.IKernel"/>. 
            This implementation is complete and also support a kernel 
            hierarchy (sub containers).
            </summary>
            <summary>
            Default implementation of <see cref="T:Castle.MicroKernel.IKernel"/>. 
            This implementation is complete and also support a kernel 
            hierarchy (sub containers).
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IKernel">
            <summary>
            The <c>IKernel</c> interface exposes all the functionality
            the MicroKernel implements.
            </summary>
            <remarks>
            It allows you to register components and
            request them by the key or the service they implemented.
            It also allow you to register facilities and subsystem, thus 
            augmenting the functionality exposed by the kernel alone to fits 
            your needs.
            <seealso cref="T:Castle.MicroKernel.IFacility"/>
            <seealso cref="T:Castle.MicroKernel.ISubSystem"/>
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.IKernelEvents">
            <summary>
            Summary description for IKernelEvents.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentRegistered">
            <summary>
            Event fired when a new component is registered 
            on the kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentUnregistered">
            <summary>
            Event fired when a component is removed from the kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentModelCreated">
            <summary>
            Event fired after the ComponentModel is created.
            Allows customizations that may affect the handler.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel">
            <summary>
            Event fired when the kernel was added as child of
            another kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.RemovedAsChildKernel">
            <summary>
            Event fired when the kernel was removed from being a child
            of another kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentCreated">
            <summary>
            Event fired before the component is created.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentDestroyed">
            <summary>
            Event fired when a component instance destroyed.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered">
            <summary>
            Event fired when a new handler is registered 
            (it might be in a valid or waiting dependency state)
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.HandlersChanged">
            <summary>
            Event fired when a new handler is registered 
            (it might be in a valid or waiting dependency state)
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.DependencyResolving">
            <summary>
            Event fired when a dependency is being resolved,
            it allows the dependency to be changed,
            but the client ComponentModel must not be changed.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Register(Castle.MicroKernel.Registration.IRegistration[])">
            <summary>
            Registers the components provided by the <see cref="T:Castle.MicroKernel.Registration.IRegistration"/>s
            with the <see cref="T:Castle.MicroKernel.IKernel"/>.
            <para/>
            Create a new registration using <see cref="T:Castle.MicroKernel.Registration.Component"/>.For() or <see cref="T:Castle.MicroKernel.Registration.AllTypes"/>.
            </summary>
            <example>
            <code>
            kernel.Register(Component.For&lt;IService&gt;().ImplementedBy&lt;DefaultService&gt;());
            </code>
            </example>
            <param name="registrations">The component registrations.</param>
            <returns>The kernel.</returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RemoveComponent(System.String)">
            <summary>
            Returns true if the specified component was 
            found and could be removed (i.e. no other component depends on it)
            </summary>
            <param name="key">The component's key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.String)">
            <summary>
            Returns true if the specified key was registered
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.Type)">
            <summary>
            Returns true if the specified service was registered
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RegisterCustomDependencies(System.Type,System.Collections.IDictionary)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="service"></param>
            <param name="dependencies"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RegisterCustomDependencies(System.Type,System.Object)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="service"></param>
            <param name="dependenciesAsAnonymousType"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RegisterCustomDependencies(System.String,System.Collections.IDictionary)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="key"></param>
            <param name="dependencies"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RegisterCustomDependencies(System.String,System.Object)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="key"></param>
            <param name="dependenciesAsAnonymousType"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ReleaseComponent(System.Object)">
            <summary>
            Releases a component instance. This allows
            the kernel to execute the proper decomission 
            lifecycles on the component instance.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.CreateComponentActivator(Castle.Core.ComponentModel)">
            <summary>
            Constructs an implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>
            for the given <see cref="T:Castle.Core.ComponentModel"/>
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.String)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/>
            for the specified component key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.Type)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/>
            for the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetAssignableHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service. 
            The check is made using IsAssignableFrom
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility(System.String,Castle.MicroKernel.IFacility)">
            <summary>
            Adds a <see cref="T:Castle.MicroKernel.IFacility"/> to the kernel.
            </summary>
            <param name="key"></param>
            <param name="facility"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.String)">
            <summary>
            Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.String,System.Action{``0})">
            <summary>
            Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
            <param name="onCreate">The callback for creation.</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.String,System.Func{``0,System.Object})">
            <summary>
            Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="key"></param>
            <param name="onCreate">The callback for creation.</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1">
            <summary>
            Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.Action{``0})">
            <summary>
            Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.Func{``0,System.Object})">
            <summary>
            Creates and adds an <see cref="T:Castle.MicroKernel.IFacility"/> facility to the kernel.
            </summary>
            <typeparam name="T">The facility type.</typeparam>
            <param name="onCreate">The callback for creation.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetFacilities">
            <summary>
            Returns the facilities registered on the kernel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddSubSystem(System.String,Castle.MicroKernel.ISubSystem)">
            <summary>
            Adds (or replaces) an <see cref="T:Castle.MicroKernel.ISubSystem"/>
            </summary>
            <param name="key"></param>
            <param name="subsystem"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetSubSystem(System.String)">
            <summary>
            Returns an implementation of <see cref="T:Castle.MicroKernel.ISubSystem"/>
            for the specified key. 
            <seealso cref="T:Castle.MicroKernel.SubSystemConstants"/>
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddChildKernel(Castle.MicroKernel.IKernel)">
            <summary>
            Support for kernel hierarchy
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RemoveChildKernel(Castle.MicroKernel.IKernel)">
            <summary>
            Remove child kernel
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RaiseHandlerRegistered(Castle.MicroKernel.IHandler)">
            <summary>
            Raise the hanlder registered event, required so
            dependant handlers will be notified about their dependant moving
            to valid state.
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RegisterHandlerForwarding(System.Type,System.String)">
            <summary>
            Registers the <paramref name="forwardedType"/> to be forwarded 
            to the component registered with <paramref name="name"/>.
            </summary>
            <param name="forwardedType">The service type that gets forwarded.</param>
            <param name="name">The name of the component to forward to.</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddHandlerSelector(Castle.MicroKernel.IHandlerSelector)">
            <summary>
            Register a new component resolver that can take part in the decision
            making about which handler to resolve
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type)">
            <summary>
            Adds a concrete class as a component
            </summary>
            <param name="key"></param>
            <param name="classType"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType)">
            <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/>, or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)">
            <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <param name="overwriteLifestyle">
            If <see langword="true"/>, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle"/> parameter.
            </param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/> or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException"/>
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type)">
            <summary>
            Adds a concrete class and an interface 
            as a component
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType)">
            <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/>, <paramref name="serviceType"/>, or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)">
            <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <param name="overwriteLifestyle">
            If <see langword="true"/>, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle"/> parameter.
            </param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/>, <paramref name="serviceType"/>, or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent``1">
            <summary>
            Adds a concrete class as a component
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent``1(Castle.Core.LifestyleType)">
            <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <remarks>
            If you have indicated a lifestyle for the specified T using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent``1(Castle.Core.LifestyleType,System.Boolean)">
            <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <param name="overwriteLifestyle">
            If <see langword="true"/>, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle"/> parameter.
            </param>
            <remarks>
            If you have indicated a lifestyle for the specified T using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentException"/>
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent``1(System.Type)">
            <summary>
            Adds a concrete class and an interface 
            as a component
            </summary>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent``1(System.Type,Castle.Core.LifestyleType)">
            <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <remarks>
            If you have indicated a lifestyle for the specified T using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent``1(System.Type,Castle.Core.LifestyleType,System.Boolean)">
            <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <param name="overwriteLifestyle">
            If <see langword="true"/>, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle"/> parameter.
            </param>
            <remarks>
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentInstance``1(System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentInstance``1(System.Type,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="serviceType"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentWithExtendedProperties(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
            Adds a concrete class as a component and specify the extended properties.
            Used by facilities, mostly.
            </summary>
            <param name="key"></param>
            <param name="classType"></param>
            <param name="extendedProperties"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentWithExtendedProperties(System.String,System.Type,System.Type,System.Collections.IDictionary)">
            <summary>
            Adds a concrete class and an interface 
            as a component and specify the extended properties.
            Used by facilities, mostly.
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="classType"></param>
            <param name="extendedProperties"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddCustomComponent(Castle.Core.ComponentModel)">
            <summary>
            Adds a custom made <see cref="T:Castle.Core.ComponentModel"/>.
            Used by facilities.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentInstance(System.String,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentInstance(System.String,System.Type,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentInstance(System.String,System.Type,System.Type,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="instance"></param>
            <param name="classType"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type)">
            <summary>
            Returns the component instance by the service type
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type)">
            <summary>
            Returns all the valid component instances by
            the service type
            </summary>
            <param name="service">The service type</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type,System.Collections.IDictionary)">
            <summary>
            Returns all the valid component instances by
            the service type
            </summary>
            <param name="service">The service type</param>
            <param name="arguments">Arguments to resolve the services</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type,System.Object)">
            <summary>
            Returns all the valid component instances by
            the service type
            </summary>
            <param name="service">The service type</param>
            <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type,System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="service"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the component key
            using dynamic arguments
            </summary>
            <param name="key"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type,System.Object)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="service">Service to resolve</param>
            <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Object)">
            <summary>
            Returns the component instance by the component key
            using dynamic arguments
            </summary>
            <param name="key">Key to resolve</param>
            <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Type)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.Object)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1">
            <summary>
            Returns the component instance by the component key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.String)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key">Component's key</param>
            <typeparam name="T">Service type</typeparam>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.String,System.Collections.IDictionary)">
            <summary>
            Returns a component instance by the key
            </summary>
            <typeparam name="T">Service type</typeparam>
            <param name="key">Component's key</param>
            <param name="arguments"></param>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll``1">
            <summary>
            Returns component instances that implement TService
            </summary>
            <typeparam name="TService"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll``1(System.Collections.IDictionary)">
            <summary>
            Returns component instances that implement TService
            </summary>
            <typeparam name="TService"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ResolveAll``1(System.Object)">
            <summary>
            Returns component instances that implement TService
            </summary>
            <typeparam name="TService"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ComponentModelBuilder">
            <summary>
            Returns the implementation of <see cref="T:Castle.MicroKernel.IComponentModelBuilder"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.HandlerFactory">
            <summary>
            Returns the implementation of <see cref="T:Castle.MicroKernel.IHandlerFactory"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ConfigurationStore">
            <summary>
            Gets or sets the implementation of <see cref="T:Castle.MicroKernel.IConfigurationStore"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ReleasePolicy">
            <summary>
            Gets or sets the implementation for <see cref="T:Castle.MicroKernel.IReleasePolicy"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Resolver">
            <summary>
            Returns the implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ProxyFactory">
            <summary>
            Gets or sets the implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            allowing different strategies for proxy creation.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Parent">
            <summary>
            Returns the parent kernel
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.GraphNodes">
            <summary>
            Graph of components and iteractions.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Item(System.String)">
            <summary>
            Returns the component instance by the key
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Item(System.Type)">
            <summary>
            Returns the component instance by the service type
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.parentKernel">
            <summary>
            The parent kernel, if exists.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.handlerFactory">
            <summary>
            The implementation of <see cref="T:Castle.MicroKernel.IHandlerFactory"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.modelBuilder">
            <summary>
            The implementation of <see cref="T:Castle.MicroKernel.IComponentModelBuilder"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.resolver">
            <summary>
            The dependency resolver.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.releaserPolicy">
            <summary>
            Implements a policy to control component's
            disposal that the usef forgot.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.proxyFactory">
            <summary>
            Holds the implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.facilities">
            <summary>
            List of <see cref="T:Castle.MicroKernel.IFacility"/> registered.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.subsystems">
            <summary>
            Map of subsystems registered.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.childKernels">
            <summary>
            List of sub containers.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor">
            <summary>
            Constructs a DefaultKernel with no component
            proxy support.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IDependencyResolver,Castle.MicroKernel.IProxyFactory)">
            <summary>
            Constructs a DefaultKernel with the specified
            implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/> and <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            </summary>
            <param name="resolver"></param>
            <param name="proxyFactory"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IProxyFactory)">
            <summary>
            Constructs a DefaultKernel with the specified
            implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Register(Castle.MicroKernel.Registration.IRegistration[])">
            <summary>
            Registers the components described by the <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1"/>s
            with the <see cref="T:Castle.MicroKernel.IKernel"/>.
            <param name="registrations">The component registrations.</param>
            <returns>The kernel.</returns>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.RemoveComponent(System.String)">
            <summary>
            Returns true if the specified component was
            found and could be removed (i.e. no other component depends on it)
            </summary>
            <param name="key">The component's key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.RegisterCustomDependencies(System.Type,System.Collections.IDictionary)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="service"></param>
            <param name="dependencies"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.RegisterCustomDependencies(System.Type,System.Object)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="service"></param>
            <param name="dependenciesAsAnonymousType"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.RegisterCustomDependencies(System.String,System.Collections.IDictionary)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="key"></param>
            <param name="dependencies"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.RegisterCustomDependencies(System.String,System.Object)">
            <summary>
            Associates objects with a component handler,
            allowing it to use the specified dictionary
            when resolving dependencies
            </summary>
            <param name="key"></param>
            <param name="dependenciesAsAnonymousType"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ReleaseComponent(System.Object)">
            <summary>
            Releases a component instance. This allows
            the kernel to execute the proper decomission
            lifecycles on the component instance.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetAssignableHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service. 
            The check is made using IsAssignableFrom
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetFacilities">
            <summary>
            Returns the facilities registered on the kernel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetService(System.Type)">
             <summary>
             Gets the service object of the specified type.
             </summary>
            
             <returns>
             A service object of type serviceType.
             </returns>
            
             <param name="serviceType">An object that specifies the type of service object to get. </param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetService``1">
             <summary>
             Gets the service object of the specified type.
             </summary>
            
             <returns>
             A service object of type serviceType.
             </returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Dispose">
            <summary>
            Starts the process of component disposal.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType)">
            <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/> or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)">
            <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <param name="overwriteLifestyle">
            If <see langword="true"/>, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle"/> parameter.
            </param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/> or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException"/>
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType)">
            <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/>, <paramref name="serviceType"/>, or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)">
            <summary>
            Adds a concrete class and an interface 
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="key">The key with which to index the component.</param>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="classType">The <see cref="T:System.Type"/> of the component.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <param name="overwriteLifestyle">
            If <see langword="true"/>, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle"/> parameter.
            </param>
            <remarks>
            If you have indicated a lifestyle for the specified <paramref name="classType"/> using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="key"/>, <paramref name="serviceType"/>, or <paramref name="classType"/>
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentWithExtendedProperties(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="classType"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentWithExtendedProperties(System.String,System.Type,System.Type,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="classType"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddCustomComponent(Castle.Core.ComponentModel)">
            <summary>
            
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentInstance(System.String,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentInstance(System.String,System.Type,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent``1">
            <summary>
            Adds a concrete class as a component
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent``1(Castle.Core.LifestyleType)">
            <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <remarks>
            If you have indicated a lifestyle for the specified T using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent``1(Castle.Core.LifestyleType,System.Boolean)">
            <summary>
            Adds a concrete class
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <param name="overwriteLifestyle">If <see langword="true"/>, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle"/> parameter.</param>
            <remarks>
            If you have indicated a lifestyle for the specified T using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentException"/>
            Thrown if 
            <paramref name="lifestyle"/>
             is 
            <see cref="F:Castle.Core.LifestyleType.Undefined"/>
            .
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent``1(System.Type)">
            <summary>
            Adds a concrete class and an interface
            as a component
            </summary>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent``1(System.Type,Castle.Core.LifestyleType)">
            <summary>
            Adds a concrete class and an interface
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <remarks>
            If you have indicated a lifestyle for the specified T using
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponent``1(System.Type,Castle.Core.LifestyleType,System.Boolean)">
            <summary>
            Adds a concrete class and an interface
            as a component with the specified <paramref name="lifestyle"/>.
            </summary>
            <param name="serviceType">The service <see cref="T:System.Type"/> that this component implements.</param>
            <param name="lifestyle">The specified <see cref="T:Castle.Core.LifestyleType"/> for the component.</param>
            <param name="overwriteLifestyle">If <see langword="true"/>, then ignores all other configurations
            for lifestyle and uses the value in the <paramref name="lifestyle"/> parameter.</param>
            <remarks>
            attributes, this method will not overwrite that lifestyle. To do that, use the
            <see cref="M:Castle.MicroKernel.DefaultKernel.AddComponent(System.String,System.Type,System.Type,Castle.Core.LifestyleType,System.Boolean)"/> method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            are <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="lifestyle"/> is <see cref="F:Castle.Core.LifestyleType.Undefined"/>.
            </exception>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentInstance``1(System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentInstance``1(System.Type,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="serviceType"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.Object)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1">
            <summary>
            Returns the component instance by the component key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.String)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key">Component's key</param>
            <typeparam name="T">Service type</typeparam>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.String,System.Collections.IDictionary)">
            <summary>
            Returns a component instance by the key
            </summary>
            <typeparam name="T">Service type</typeparam>
            <param name="key">Component's key</param>
            <param name="arguments"></param>
            <returns>The Component instance</returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type)">
            <summary>
            Returns the component instance by the service type
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll(System.Type)">
            <summary>
            Returns all the valid component instances by
            the service type
            </summary>
            <param name="service">The service type</param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll(System.Type,System.Collections.IDictionary)">
            <summary>
            Returns all the valid component instances by
            the service type
            </summary>
            <param name="service">The service type</param>
            <param name="arguments">Arguments to resolve the services</param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll(System.Type,System.Object)">
            <summary>
            Returns all the valid component instances by
            the service type
            </summary>
            <param name="service">The service type</param>
            <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll``1(System.Object)">
            <summary>
            Returns component instances that implement TService
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll``1(System.Collections.IDictionary)">
            <summary>
            Returns component instances that implement TService
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type,System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="service"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type,System.Object)">
            <summary>
            Returns the component instance by the service type
            using dynamic arguments
            </summary>
            <param name="service"></param>
            <param name="argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Collections.IDictionary)">
            <summary>
            Returns the component instance by the component key
            using dynamic arguments
            </summary>
            <param name="key"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Object)">
            <summary>
            Returns the component instance by the component key
            using dynamic arguments
            </summary>
            <param name="key"></param>
            <param name="argumentsAsAnonymousType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll``1">
            <summary>
            Returns component instances that implement TService
            </summary>
            <typeparam name="TService"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type,System.Object)">
            <summary>
            Resolves the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="service">The service.</param>
            <param name="argumentsAsAnonymousType">Type of the arguments as anonymous.</param>
            <returns></returns>
        </member>
        <member name="P:Castle.MicroKernel.DefaultKernel.GraphNodes">
            <summary>
            Graph of components and iteractions.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.DefaultKernel.HandlerRegistered">
            <summary>
            Pending
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.DefaultKernel.ComponentRegistered">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.DefaultKernel.ComponentUnregistered">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.DefaultKernel.ComponentCreated">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.DefaultKernel.ComponentDestroyed">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.DefaultKernel.AddedAsChildKernel">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.DefaultKernel.RemovedAsChildKernel">
            <summary>
            Pending
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.DefaultKernel.ComponentModelCreated">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="T:Castle.MicroKernel.ComponentDataDelegate">
            <summary>
            Represents a delegate which holds basic information about a component.
            </summary>
            <param name="key">Key which identifies the component</param>
            <param name="handler">handler that holds this component and is capable of 
            creating an instance of it.
            </param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentInstanceDelegate">
            <summary>
            Represents a delegate which holds basic information about a component
            and its instance.
            </summary>
            <param name="model">Component meta information</param>
            <param name="instance">Component instance</param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentModelDelegate">
            <summary>
            Represents a delegate which holds the information about the 
            component
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.HandlerDelegate">
            <summary>
            Represents a delegate which holds a handler
            </summary>
            <param name="handler">handler that holds a component and is capable of 
            creating an instance of it.
            </param>
            <param name="stateChanged"></param>
        </member>
        <member name="T:Castle.MicroKernel.DependencyDelegate">
            <summary>
            Represents a delegate which holds dependency
            resolving information.
            </summary>
        </member>
    </members>
</doc>
